## 红黑二叉树



[![红黑树](https://camo.githubusercontent.com/971cdd1ba73f4e44ea930efcd14a31bdda4b1c23/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f31342f313637313161633239633133386362613f773d38353126683d36313426663d6a70656726733d3334343538)](https://camo.githubusercontent.com/971cdd1ba73f4e44ea930efcd14a31bdda4b1c23/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f31342f313637313161633239633133386362613f773d38353126683d36313426663d6a70656726733d3334343538)

**红黑树特点:**

1. 每个节点非红即黑；
2. 根节点总是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL节点）；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）

**红黑树的应用：**

TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。

**为什么要用红黑树**

简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

### 3.4 红黑树这么优秀，为何不直接使用红黑树得了？

说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。

