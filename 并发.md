## 一、原子类

![img](https://camo.githubusercontent.com/8d43784c43dcc9f46d3cc917066fb945fa877857/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f33302f313636633538623738353336383233343f773d3132303026683d36353726663d706e6726733d3439363135)

### 1. 基本原子类

基本原子类主要有：

- AtomicInteger：整形原子类
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

每个类中的方法基本都是相同，类似于下面的样子：

```java
public final int get() //获取当前的值
public final int getAndSet(int newValue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement() //获取当前的值，并自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

**优点**是能够在多环境使用原子类保证线程安全

**基本原子类实现原理：**主要利用CAS（compare and swap） + volatile 和 native方法来保证原子操作，从而避免synchronized的高开销，提高执行效率。

### 2. 数组类型原子类

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整形数组原子类
- AtomicLongArray：长整形数组原子类
- AtomicReferenceArray ：引用类型数组原子类

其中基本的方法基本相同，类似于如下所示：

```java
public final int get(int i) //获取 index=i 位置元素的值
public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue
public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndAdd(int delta) //获取 index=i 位置元素的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

### 3. 引用类型原子类

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。

- AtomicReference：引用类型原子类
- AtomicStampedRerence：原子更新引用类型里的字段原子类
- AtomicMarkableReference ：原子更新带有标记位的引用类型

上面三个类提供的方法几乎相同，主要的功能是**为引用类型提供原子操作管理**。

```java
AtomicReference<Person> ar = new AtomicReference<Person>(); //是一个引用管理，保证引用类型处理时的原子性
```

### 4. 对象属性修改类型原子类

如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。

- AtomicIntegerFieldUpdater:原子更新整形字段的更新器
- AtomicLongFieldUpdater：原子更新长整形字段的更新器
- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。

```java
AtomicIntegerFieldUpdater<User> a = AtomicIntegerFieldUpdater.newUpdater(User.class, "age"); //直接对象的中的作用域进行原子操作
a.getAndIncrement(user)；
```

##  二、AQS(AbstractQueuedSynchronizer)

![AQS](https://camo.githubusercontent.com/75950bb0b6b7ba5672236abf0c7c096a822b1d39/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d33312f36313131353836352e6a7067)

### 1. 简单介绍

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。

###  2. AQS原理

**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

CLH队列是一个虚拟的双向队列。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个节点（Node）来实现锁的分配。

AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。

AQS定义两种资源共享方式：Exclusive(独占，如ReentrantLock)和Share(共享，如Semaphore、CountDownLatch、CyclicBarrier、ReadWriteLock)

使用了模板方法模式，自定义同步器需要重写下面几个AQS提供的模板方法

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

1. **Se**maphore经常用于限制获取某种资源线程数量。**

   支持公平模式和非公平模式，通过调用acquire方法得到申请许可，通过调用release释放许可。

2. **CountDownLatch（倒计时器）**

   它允许一个或多个线程等待，直到其他的线程执行完后再执行。

   三种典型用法：某一个线程开始运行前等待n个线程执行完毕；实现多个线程开始执行任务的最大并行性；死锁检测。

3. **CyclicBarrier(循环栅栏)**

   和CountDownLatch非常相似，它可以实现线程间的计数等待，但是功能比CountDownLatch更加复杂和强大。适用于多线程计算数据，最后合并计算结果的应用场景。使用实例如下所示

   ```java
   private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5); //其中5代表需要达到的等待线程条件，支持两个参数，后面可以添加一个方法优先于子线程子线程执行
   
   //子线程中操作
   cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);
   //当有五个线程调用await后才继续执行await后面的方法
   ```

   **CyclicBarrier和CountDownLatch的区别**

   1. CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。
   2. 对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
   3. CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

![CyclicBarrieråCountDownLatchçåºå"](https://camo.githubusercontent.com/5c19d9e66ffaf3d7193b01948279db9b9b3b98d3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f4151533333332e706e67)

## 三、CopyOnWriteArrayList

和ReetrantReadWriteLock读写锁的思想非常类似，也是存在写则互斥，或者否则共享。读取完全不用加锁，写入也不会阻塞读取操作。

**原理：**类中所有的可变操作都是通过创建底层数组的新副本来实现。写入操作在添加集合的时候加了锁，保证了同步，避免了多线程写的时候回copy出多个副本来

## 四、java之同步集合和并发集合

### 4.1 **同步集合类**

- HashTable
- Vector
- 同步集合包装类，Collections.synchronizedMap()和Colletions.synchronizedList()

#### 4.1.1 实现原理

就是最简单的每次操作之前锁住整个表。

### 4.2 **并发集合类**

- ConcurrentHashmap
- CopyOnWriteArrayList，存在问题，数据一致性以及内存占用问题
- CopyOnWriteHashSet

#### 4.2.1 实现原理

- ConcurrentHashMap：把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。**之前是分段上锁，后面变成了针对里面的节点进行，大大地加快了并发的程度**
- CopyOnWriteArrayList：允许多个线程以**非同步的方式读**，当有线程写的时候它会将整个List复制一个副本给它。如果在**读多写少（适用场景）**这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。**原理特别简单就是在存在写时就往副本里写，写完以后更新引用**

#### 4.2.2 使用建议

一般在不需要使用多线程的情况下，只用到HashMap、ArrayList，只要真正用到多线程的时候就一定要考虑使用同步，使用同步集合或者并发集合。

### 4.3 **性能**

同步集合比并发集合会慢得多，主要原因是锁，同步集合会对整个May或List加锁

## 五、锁优化



这里的锁优化主要是指 JVM 对 synchronized 的优化。

### 5.1 自旋锁

互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。（**能够动态地不断优化自旋时间**）

### 5.2 锁消除

锁消除是指对于**被检测出不可能存在竞争的共享数据的锁进行消除**。

锁消除主要是通过**逃逸分**来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。
对于一些看起来没有加锁的代码，其实隐式的加了很多锁，例如每个 StringBuilder.append() 方法中都有一个同步块。
#### 5.2.1 逃逸分析
逃逸分析的基本行为就是分析对象动态作用域,即对象可以在作用域外访问则说明发生了逃逸。
**方法逃逸:**：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。
**线程逃逸:** 甚至可以被外部线程访问，则称为线程逃逸。

###### 5.2.1.1 基于逃逸分析可以实现：
一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

### 5.3 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。
如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部

### 5.4 轻量级锁

JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。

![img](https://cyc2018.github.io/CS-Notes/pics/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png)

下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。

![img](https://cyc2018.github.io/CS-Notes/pics/051e436c-0e46-4c59-8f67-52d89d656182.png)

轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

![img](https://cyc2018.github.io/CS-Notes/pics/baaa681f-7c52-4198-a5ae-303b9386cf47.png)

如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

### 5.5 偏向锁

偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。**让第一个获取锁对象的线程之后不用再次获取锁**

当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

![img](https://cyc2018.github.io/CS-Notes/pics/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg)