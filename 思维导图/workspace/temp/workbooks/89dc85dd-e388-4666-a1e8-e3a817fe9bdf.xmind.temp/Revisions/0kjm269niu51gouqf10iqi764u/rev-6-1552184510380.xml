<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="0kjm269niu51gouqf10iqi764u" modified-by="lq_lab" theme="3v24g6t6sgm0dg9c5daor85hrg" timestamp="1552184505229" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="724l6fbbbncimuvribmsus2lq1" modified-by="lq_lab" structure-class="org.xmind.ui.map.unbalanced" timestamp="1552184281302"><title>垃圾收集器</title><children><topics type="attached"><topic id="65ejh7mpgu9q05s6t0t9rgj5d9" modified-by="lq_lab" timestamp="1552181033299"><title>垃圾收集算法</title><children><topics type="attached"><topic id="1grhhnmlp9qn7qmmi21e8fbtv0" modified-by="lq_lab" timestamp="1552181033296"><title>标记-删除法</title><children><topics type="attached"><topic id="6b5q39ugpvng34ac0437tgkm4a" modified-by="lq_lab" timestamp="1552181033295"><title>优点</title><children><topics type="attached"><topic id="0v4j560v0d37hqrdsnpg0gsd1e" modified-by="lq_lab" timestamp="1552181033294"><title>简单高效</title></topic><topic id="29fsrvj1bq4ptkd35uck4iuoto" modified-by="lq_lab" timestamp="1552181033294"><title>串行</title></topic></topics></children></topic><topic id="7adgkclueu6i06vmmu50ckglfk" modified-by="lq_lab" timestamp="1552181033295"><title>缺点</title><children><topics type="attached"><topic id="319ic2haj8tacd7rdf8aeetmki" modified-by="lq_lab" timestamp="1552181033295"><title>内存不连续（碎片化严重）</title></topic></topics></children></topic><topic id="1sb3sum30cgg5fvk7ge5ilrdnk" modified-by="lq_lab" timestamp="1552181033295"><title>client场景下默认的新生代收集器</title></topic></topics></children></topic><topic id="7bs7bh7l57t4439khg9fpnlgjp" modified-by="lq_lab" timestamp="1552181033296"><title>复制法</title><children><topics type="attached"><topic id="5m2j4kjn1udrens0ergbr7v3fd" modified-by="lq_lab" timestamp="1552181033296"><title svg:width="500">将内存分块，将存活的部分往空闲块拷，清除块，（现在一般分为三块，一块Eden两块Survivor）</title></topic><topic id="7gee70kibc7uv0bv1i2c90468s" modified-by="lq_lab" timestamp="1552181033296"><title svg:width="500">空间连续，需要额外的空间进行分配担保，但是浪费空间，如果存活对象太多，复杂花费时间太久</title></topic></topics></children></topic><topic id="3ch0r6lrjl2klq5602i3h6cifc" modified-by="lq_lab" timestamp="1552181033297"><title>标记-移动法（标记-整理）</title><children><topics type="attached"><topic id="1ge6bfdst0ss8b8ictjkvg7aot" modified-by="lq_lab" timestamp="1552181033297"><title>所有存活的对象向一端移动，直接清理掉端边界外的内存</title></topic><topic id="389fvmhcdcfre38i6nen0mlko4" modified-by="lq_lab" timestamp="1552181033297"><title>优点是不需要额外空间进行担保</title></topic></topics></children></topic><topic id="4tkn6gto4nv4m0fn6r522r629h" modified-by="lq_lab" timestamp="1552181033299"><title>分代收集算法</title><children><topics type="attached"><topic id="16eagevt0juu8p6ldft8ob4i4v" modified-by="lq_lab" timestamp="1552181033298"><title>一种思想，并不是实际的收集算法</title></topic><topic id="6u5jk55gqab3fpb36u4kq74mgu" modified-by="lq_lab" timestamp="1552181033298"><title>新生代</title><children><topics type="attached"><topic id="0m51be8qmqmss31u566596tv3d" modified-by="lq_lab" timestamp="1552181033298"><title>复制法</title></topic></topics></children></topic><topic id="6d6ivh4s9bv914hd7vn9fkrs6j" modified-by="lq_lab" timestamp="1552181033299"><title>老年代</title><children><topics type="attached"><topic id="0u3a28sbc51a4h024t1l52fle5" modified-by="lq_lab" timestamp="1552181033299"><title>标记-清除、标记-整理算法</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7phv2ucpk459ae2gcd55e9doc9" modified-by="lq_lab" timestamp="1552181033302"><title>基本概念</title><children><topics type="attached"><topic id="0lm780ce6odsj4rv56nj11gls3" modified-by="lq_lab" timestamp="1552181275131"><title>Safe Point(安全点)</title><children><topics type="attached"><topic id="2gojmt2c62e0bvigfllj76bq0o" modified-by="lq_lab" timestamp="1552181118997"><title>在安全点具有OopMap数据（哪些位置具有对象引用）</title></topic><topic id="6hjhm08v1e1jc1dr1cp5od5o2h" modified-by="lq_lab" timestamp="1552181230248"><title>到达方式（中断）</title><children><topics type="attached"><topic id="5o0n0vd3o2hng9cifdutu3516b" modified-by="lq_lab" timestamp="1552181194563"><title>抢先式（Preemptive Suspension）</title></topic><topic id="6q0svmabig12so3trsr8qcpdps" modified-by="lq_lab" timestamp="1552181221937"><title>主动式（Voluntary Suspension）</title></topic></topics></children></topic><topic id="10frmp21bvfdgk6litdptj20no" modified-by="lq_lab" timestamp="1552181334152"><title>Safe Region（安全区域）</title><children><topics type="attached"><topic id="1gu6f46c35mj7erd2f13r13qfr" modified-by="lq_lab" timestamp="1552181323899"><title svg:width="500">一段代码片段中，引用关系不会发生变化，任意地方开始GC都是安全的</title></topic></topics></children></topic></topics></children></topic><topic id="15326ckfj9crsn887ep548c2pm" modified-by="lq_lab" timestamp="1552181033300"><title>Stop The World（停下所有的工作线程）</title></topic><topic id="293huohr2ehc4paecmmljptreu" modified-by="lq_lab" timestamp="1552181033302"><title>GC Root(枚举根节点)</title><children><topics type="attached"><topic id="67s1vnqf1nmuhufrct2u0v4d8a" modified-by="lq_lab" timestamp="1552181033300"><title>由系统类加载器（BootStrap）加载对对象（Class）</title></topic><topic id="7q5f2a1314ql8qjc38n9lb0hcj" modified-by="lq_lab" timestamp="1552181033301"><title>活着的线程</title></topic><topic id="4a756ejhl5lh17g0bpecl12ibq" modified-by="lq_lab" timestamp="1552181033301"><title svg:width="500">java方法的local变量或参数（理解，这些一旦存在说明方法正在被调用，这些不能回收，方法运行完能自动回收）</title></topic><topic id="6tvd4khgfcaidu1j5uic071is0" modified-by="lq_lab" timestamp="1552181033302"><title>JNI方法的Local变量或参数</title></topic><topic id="6cg2511pj6b3l39ggir2l4rhqk" modified-by="lq_lab" timestamp="1552181033302"><title>JNI全局引用</title></topic><topic id="4pdnjai5lsspta3clgebhs7749" modified-by="lq_lab" timestamp="1552181033302"><title>用于同步的监控对象</title></topic><topic id="11oqkv7iqntkpo2j8gn4mirveb" modified-by="lq_lab" timestamp="1552181033302"><title svg:width="500">Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的</title></topic></topics></children></topic></topics></children></topic><topic id="4orpp651s99hrjmbsdgledvnbe" modified-by="lq_lab" timestamp="1552181627222"><title>垃圾收集器</title><children><topics type="attached"><topic id="6ldn5jmbpilt1pti9fg9vsdj04" modified-by="lq_lab" timestamp="1552181673208"><title>核心：没有最优，只有适合，每代需要选择合适的收集器</title></topic><topic id="17nkafm684ioo7jvia40564hc1" modified-by="lq_lab" timestamp="1552181627194"><title/><xhtml:img align="bottom" xhtml:src="xap:attachments/26vt2s7c0bqqit40pfp3ooc482.png"/></topic><topic id="4qvebf043shaei07d3uphckr3h" modified-by="lq_lab" timestamp="1552183993125"><title>各代使用收集器</title><children><topics type="attached"><topic id="5livcc2utubiehe1785uqlnbhs" modified-by="lq_lab" timestamp="1552182464144"><title>新生代</title><children><topics type="attached"><topic id="4pe2j4ja5jqk452cehs12lu55q" modified-by="lq_lab" timestamp="1552182472775"><title>核心算法都是：复制（新生代）+标记整理（老年代）</title></topic><topic id="25l7ep8lfr09ort462bkaago5g" modified-by="lq_lab" timestamp="1552182464132"><title>Serial</title><children><topics type="attached"><topic id="0j92jga4kgkaobidmrds1v5imo" modified-by="lq_lab" timestamp="1552182436975"><title>单线程 + stop the world</title></topic><topic id="11gji2tp56p7fnjhc14m2nd0ri" modified-by="lq_lab" timestamp="1552181725648"><title>简单高效，单CPU情况下具有最高的单线程收集效率</title></topic><topic id="2c34orhhmbscngmdn9f4n32kpd" modified-by="lq_lab" timestamp="1552182361480"><title svg:width="500">client模式下默认新生代收集器，小内存情况下，垃圾收集停顿时间很小（但也有停顿）</title></topic></topics></children></topic><topic id="1jp6ikffkdo3mf3qpdvi6ocp40" modified-by="lq_lab" timestamp="1552182475591"><title>ParNew</title><children><topics type="attached"><topic id="4m1275q932sf0reic82os0b0ub" modified-by="lq_lab" timestamp="1552182433697"><title>多线程（Serial的多线程版本）+ stop the world</title></topic><topic id="19j0b4ud04lbcsonot765kq11s" modified-by="lq_lab" timestamp="1552181936170"><title>Server模式下默认的新生代收集器（选择原因：性能+能配合CMS）</title></topic></topics></children></topic><topic id="0e0kll6olklubmvc0cqd7s75es" modified-by="lq_lab" timestamp="1552183208699"><title>Parallel Scavenge</title><children><topics type="attached"><topic id="52r2oli7ko66iejdc9tlgpqg4h" modified-by="lq_lab" timestamp="1552182426401"><title>多线程 + stop the world</title></topic><topic id="1bjqlprd91kv4n821k0ahi6n7h" modified-by="lq_lab" timestamp="1552183208711"><title>特点</title><children><topics type="attached"><topic id="07jk99r97q90uj6l9tnfft4i88" modified-by="lq_lab" timestamp="1552183208700"><title svg:width="500">关注吞吐量（但是参数有虚拟机自行优化），就是用户代码运行时间的占比尽可能高</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6fs3gte4blqat7eeqkuldo307f" modified-by="lq_lab" timestamp="1552182865093"><title>老年代</title><children><topics type="attached"><topic id="158lpa87nlvltcle1ubv6dnfo4" modified-by="lq_lab" timestamp="1552183215515"><title>Serial Old(MSC)</title><children><topics type="attached"><topic id="1tl97ju2rq2sf8albte1ig1ovf" modified-by="lq_lab" timestamp="1552183099198"><title>单线程 + Serial收集器的老年代版本</title></topic><topic id="2v7iuocjbidv2nkmafjk6j82up" modified-by="lq_lab" timestamp="1552183073832"><title>用途</title><children><topics type="attached"><topic id="3fohhs53efekvk885d9k0ehul7" modified-by="lq_lab" timestamp="1552183066208"><title>jdk1.5 之前和parallel  Scavenge搭配使用</title></topic><topic id="1ntpofephlm71d6tqmu581f23n" modified-by="lq_lab" timestamp="1552183073824"><title>作为CMS的后备方法（并发收集发生Concurrent Mode Failure时）</title></topic></topics></children></topic></topics></children></topic><topic id="65llbh2qrlh7qnjhnjij6sa0dn" modified-by="lq_lab" timestamp="1552183129962"><title>Parallel Old</title><children><topics type="attached"><topic id="12jac4pifvdmu0int00v2ladgg" modified-by="lq_lab" timestamp="1552183126513"><title>单线程 + Parallel Scavenge收集器老年代版本</title></topic><topic id="6qunoc7ki2fugi1ad869c5is5r" modified-by="lq_lab" timestamp="1552183190317"><title>使用场景：注重吞吐量+CPU敏感的场合</title></topic></topics></children></topic><topic id="1ee06rk4msdh9g50kqpc72rf0g" modified-by="lq_lab" timestamp="1552183726396"><title>CMS</title><children><topics type="attached"><topic id="6ae7a3adhagvomdsbiho4dqr7k" modified-by="lq_lab" timestamp="1552182755197"><title>尽可能压缩停顿时间</title><children><topics type="attached"><topic id="7mcfs25k45otan3s7sset2bh6f" modified-by="lq_lab" timestamp="1552182816993"><title svg:width="500">通过牺牲吞吐量和新生代空间换取：新生代空间变小，垃圾回收频繁，吞吐量下降</title></topic></topics></children></topic><topic id="0ajqfrjkjvf10h4c3qu2mvfrrk" modified-by="lq_lab" timestamp="1552183509385"><title>并发收集（收集线程和工作线程同时运行）</title></topic><topic id="0lav68pmncfh1tdjc5rvaopc6d" modified-by="lq_lab" timestamp="1552183629640"><title>标记-清除算法实现</title><children><topics type="attached"><topic id="2nvivirnlk0djrkf7k056q5ke0" modified-by="lq_lab" timestamp="1552183667527"><title>1. 初始标识（停）</title><children><topics type="attached"><topic id="0ub9o0tu1ap7qtneg5nnoemn93" modified-by="lq_lab" timestamp="1552183550367"><title>暂停所有的其他线程，记录直接与root相连的对象（速度很快）</title></topic></topics></children></topic><topic id="3ptfugqbjks49ns5pp1sjfcmrb" modified-by="lq_lab" timestamp="1552183675710"><title>2. 并发标识（不停）</title><children><topics type="attached"><topic id="3kvlhmuntkr919alq79hr9vkkp" modified-by="lq_lab" timestamp="1552183585519"><title>同时开启GC和用户线程，用一个闭包结构取记录可达对象。由于用户线程会更新引用，所以需要记录更新的位置</title></topic></topics></children></topic><topic id="4jnvudvj2iunqi206bls452jhk" modified-by="lq_lab" timestamp="1552183686856"><title>3. 重新标记（停）</title><children><topics type="attached"><topic id="6seqcgu86f7k2e5afnuanda9tv" modified-by="lq_lab" timestamp="1552183622576"><title>停下所有用户线程（这个停顿的时间远比并发标识的时间少），修正并发标识期间修改的标识。</title></topic></topics></children></topic><topic id="0mauojuutbg6j1fl8p4mjn5iek" modified-by="lq_lab" timestamp="1552183692341"><title>4. 并发清除（不停）</title><children><topics type="attached"><topic id="5g5sdb40oefkfllmorfrdkgbge" modified-by="lq_lab" timestamp="1552183651840"><title>开启用户线程，同时GC开始对标记区域做清扫</title></topic></topics></children></topic></topics></children></topic><topic id="0ojv8estmtadlu4ro2uileo6lq" modified-by="lq_lab" timestamp="1552183724596"><title>优点</title><children><topics type="attached"><topic id="22k913tllccitlbqd7p39hih7h" modified-by="lq_lab" timestamp="1552183722061"><title>并发收集、低停顿</title></topic></topics></children></topic><topic id="03u6gjdi13n7ogc0dr4j3ii2td" modified-by="lq_lab" timestamp="1552183778303"><title>缺点</title><children><topics type="attached"><topic id="4kqth29v952boosnfcpj4lnhuu" modified-by="lq_lab" timestamp="1552183761177"><title>吞吐量低，对cpu资源敏感</title></topic><topic id="0ad4ji5vmqb53q785glbmjf6ja" modified-by="lq_lab" timestamp="1552183768003"><title>无法处理浮动垃圾</title></topic><topic id="6sh4khbvc7qodfdo80ekgeiiis" modified-by="lq_lab" timestamp="1552183775022"><title>回收算法采用“标记-清除”，产生大量碎片</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2rmam18qvvd1ep5aqq7rh7cmve" modified-by="lq_lab" timestamp="1552184238341"><title>G1</title><children><topics type="attached"><topic id="79q0qss2bg17m9hvt60jj3nh7l" modified-by="lq_lab" timestamp="1552184081305"><title>描述</title><children><topics type="attached"><topic id="1q7mmv8u640802uab9vc1g7ul6" modified-by="lq_lab" timestamp="1552183884858"><title>面向服务器（打算干掉CMS）</title></topic><topic id="63hf25aomq02b4jeil69ij9a1g" modified-by="lq_lab" timestamp="1552183906700"><title>适用于多CPU和大内存场景</title></topic><topic id="29b8n0qhi724lefgnes02nno46" modified-by="lq_lab" timestamp="1552183932768"><title>新/老年代都能收集</title></topic></topics></children></topic><topic id="27ahsplpq7toc9r7f5auenr60o" modified-by="lq_lab" timestamp="1552184000568"><title>特点</title><children><topics type="attached"><topic id="39431sp6ot81gqfs029n7u6dle" modified-by="lq_lab" timestamp="1552184003784"><title svg:width="500">- 并发与并行：充分利用多核资源，使得GC收集器和应用程序可以并发执行</title></topic><topic id="1a8gva3edgnoskc7uaqslo0cv5" modified-by="lq_lab" timestamp="1552183994114"><title>- 分代收集：不需要其他的收集器配合就能独立管理，但是依然保留分代概念</title></topic><topic id="3fo5pn8mppc6rl0nuj98qcncmr" modified-by="lq_lab" timestamp="1552183994114"><title>- 空间整理：从整体上看属于“标记-整理”，从局部上看数据“标记-复制”算法。</title></topic><topic id="1igsli5vu5rega83c1s3f2m1a2" modified-by="lq_lab" timestamp="1552184093686"><title>- 可预测的停顿：还能建立可预测的停顿时间模型，让使用者明确指定在一个长度为M毫秒的时间片段内</title><children><topics type="attached"><topic id="5tscaq5bsj9uvnt3blvp8odr5j" modified-by="lq_lab" timestamp="1552184231852"><title svg:width="500">引入的Region概念，灵活性增强，维护优先列表，优先收集价值最大的Region</title></topic></topics></children></topic></topics></children></topic><topic id="3ohsedirk9tuauc2mbgo82r9oq" modified-by="lq_lab" timestamp="1552184282991"><title>步骤</title><children><topics type="attached"><topic id="3rc80o64qcdum36t1ea42s85ft" modified-by="lq_lab" timestamp="1552184344451"><title>- 初始标记（停）</title></topic><topic id="4itg2ivfk03f5u5sq34dbbvifa" modified-by="lq_lab" timestamp="1552184349240"><title>- 并发标记（不停）</title></topic><topic id="1e1532a9750uvg4r0t586f0irh" modified-by="lq_lab" timestamp="1552184462779"><title>- 最终标记（停，但可不停）</title><children><topics type="attached"><topic id="0lcd8pjmp7bfufjje0adm88tcl" modified-by="lq_lab" timestamp="1552184436043"><title>修正因为并发导致的引用关系的变动</title></topic></topics></children></topic><topic id="1urqktlc25is58em3hnm1tr6r4" modified-by="lq_lab" timestamp="1552184463528"><title>- 筛选回收（停，但可不停，但是时间可控，停性能更好）</title><children><topics type="attached"><topic id="0kpvh8rkd4rrr4dqal3camp3rt" modified-by="lq_lab" timestamp="1552184505228"><title svg:width="500">对各个Region的价值和回收成本排序，根据用户期望的停顿时间指定回收计划</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>3</right-number></content></extension></extensions></topic><title>画布 1</title></sheet></xmap-revision-content>