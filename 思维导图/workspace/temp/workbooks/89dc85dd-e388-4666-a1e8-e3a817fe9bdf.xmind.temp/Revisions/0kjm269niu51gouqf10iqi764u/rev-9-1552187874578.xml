<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="0kjm269niu51gouqf10iqi764u" modified-by="lq_lab" theme="3v24g6t6sgm0dg9c5daor85hrg" timestamp="1552187868098" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="724l6fbbbncimuvribmsus2lq1" modified-by="lq_lab" structure-class="org.xmind.ui.map.unbalanced" timestamp="1552187868098"><title>垃圾收集 GC</title><children><topics type="attached"><topic id="65ejh7mpgu9q05s6t0t9rgj5d9" modified-by="lq_lab" timestamp="1552187868098"><title>垃圾收集算法</title><children><topics type="attached"><topic id="1grhhnmlp9qn7qmmi21e8fbtv0" modified-by="lq_lab" timestamp="1552181033296"><title>标记-删除法</title><children><topics type="attached"><topic id="6b5q39ugpvng34ac0437tgkm4a" modified-by="lq_lab" timestamp="1552181033295"><title>优点</title><children><topics type="attached"><topic id="0v4j560v0d37hqrdsnpg0gsd1e" modified-by="lq_lab" timestamp="1552181033294"><title>简单高效</title></topic><topic id="29fsrvj1bq4ptkd35uck4iuoto" modified-by="lq_lab" timestamp="1552181033294"><title>串行</title></topic></topics></children></topic><topic id="7adgkclueu6i06vmmu50ckglfk" modified-by="lq_lab" timestamp="1552181033295"><title>缺点</title><children><topics type="attached"><topic id="319ic2haj8tacd7rdf8aeetmki" modified-by="lq_lab" timestamp="1552181033295"><title>内存不连续（碎片化严重）</title></topic></topics></children></topic><topic id="1sb3sum30cgg5fvk7ge5ilrdnk" modified-by="lq_lab" timestamp="1552181033295"><title>client场景下默认的新生代收集器</title></topic></topics></children></topic><topic id="7bs7bh7l57t4439khg9fpnlgjp" modified-by="lq_lab" timestamp="1552181033296"><title>复制法</title><children><topics type="attached"><topic id="5m2j4kjn1udrens0ergbr7v3fd" modified-by="lq_lab" timestamp="1552181033296"><title svg:width="500">将内存分块，将存活的部分往空闲块拷，清除块，（现在一般分为三块，一块Eden两块Survivor）</title></topic><topic id="7gee70kibc7uv0bv1i2c90468s" modified-by="lq_lab" timestamp="1552181033296"><title svg:width="500">空间连续，需要额外的空间进行分配担保，但是浪费空间，如果存活对象太多，复杂花费时间太久</title></topic></topics></children></topic><topic id="3ch0r6lrjl2klq5602i3h6cifc" modified-by="lq_lab" timestamp="1552181033297"><title>标记-移动法（标记-整理）</title><children><topics type="attached"><topic id="1ge6bfdst0ss8b8ictjkvg7aot" modified-by="lq_lab" timestamp="1552181033297"><title>所有存活的对象向一端移动，直接清理掉端边界外的内存</title></topic><topic id="389fvmhcdcfre38i6nen0mlko4" modified-by="lq_lab" timestamp="1552181033297"><title>优点是不需要额外空间进行担保</title></topic></topics></children></topic><topic id="4tkn6gto4nv4m0fn6r522r629h" modified-by="lq_lab" timestamp="1552187868072"><title>分代收集算法</title><children><topics type="attached"><topic id="16eagevt0juu8p6ldft8ob4i4v" modified-by="lq_lab" timestamp="1552181033298"><title>一种思想，并不是实际的收集算法</title></topic><topic id="6u5jk55gqab3fpb36u4kq74mgu" modified-by="lq_lab" timestamp="1552181033298"><title>新生代</title><children><topics type="attached"><topic id="0m51be8qmqmss31u566596tv3d" modified-by="lq_lab" timestamp="1552181033298"><title>复制法</title></topic></topics></children></topic><topic id="6d6ivh4s9bv914hd7vn9fkrs6j" modified-by="lq_lab" timestamp="1552181033299"><title>老年代</title><children><topics type="attached"><topic id="0u3a28sbc51a4h024t1l52fle5" modified-by="lq_lab" timestamp="1552181033299"><title>标记-清除、标记-整理算法</title></topic></topics></children></topic></topics></children></topic><topic id="7phv2ucpk459ae2gcd55e9doc9" modified-by="lq_lab" timestamp="1552187865566"><title>基本概念</title><children><topics type="attached"><topic id="0lm780ce6odsj4rv56nj11gls3" modified-by="lq_lab" timestamp="1552181275131"><title>Safe Point(安全点)</title><children><topics type="attached"><topic id="2gojmt2c62e0bvigfllj76bq0o" modified-by="lq_lab" timestamp="1552181118997"><title>在安全点具有OopMap数据（哪些位置具有对象引用）</title></topic><topic id="6hjhm08v1e1jc1dr1cp5od5o2h" modified-by="lq_lab" timestamp="1552181230248"><title>到达方式（中断）</title><children><topics type="attached"><topic id="5o0n0vd3o2hng9cifdutu3516b" modified-by="lq_lab" timestamp="1552181194563"><title>抢先式（Preemptive Suspension）</title></topic><topic id="6q0svmabig12so3trsr8qcpdps" modified-by="lq_lab" timestamp="1552181221937"><title>主动式（Voluntary Suspension）</title></topic></topics></children></topic><topic id="10frmp21bvfdgk6litdptj20no" modified-by="lq_lab" timestamp="1552181334152"><title>Safe Region（安全区域）</title><children><topics type="attached"><topic id="1gu6f46c35mj7erd2f13r13qfr" modified-by="lq_lab" timestamp="1552181323899"><title svg:width="500">一段代码片段中，引用关系不会发生变化，任意地方开始GC都是安全的</title></topic></topics></children></topic></topics></children></topic><topic id="15326ckfj9crsn887ep548c2pm" modified-by="lq_lab" timestamp="1552181033300"><title>Stop The World（停下所有的工作线程）</title></topic></topics></children></topic></topics></children></topic><topic id="4orpp651s99hrjmbsdgledvnbe" modified-by="lq_lab" timestamp="1552181627222"><title>垃圾收集器</title><children><topics type="attached"><topic id="6ldn5jmbpilt1pti9fg9vsdj04" modified-by="lq_lab" timestamp="1552181673208"><title>核心：没有最优，只有适合，每代需要选择合适的收集器</title></topic><topic id="17nkafm684ioo7jvia40564hc1" modified-by="lq_lab" timestamp="1552181627194"><title/><xhtml:img align="bottom" xhtml:src="xap:attachments/26vt2s7c0bqqit40pfp3ooc482.png"/></topic><topic id="4qvebf043shaei07d3uphckr3h" modified-by="lq_lab" timestamp="1552183993125"><title>各代使用收集器</title><children><topics type="attached"><topic id="5livcc2utubiehe1785uqlnbhs" modified-by="lq_lab" timestamp="1552182464144"><title>新生代</title><children><topics type="attached"><topic id="4pe2j4ja5jqk452cehs12lu55q" modified-by="lq_lab" timestamp="1552182472775"><title>核心算法都是：复制（新生代）+标记整理（老年代）</title></topic><topic id="25l7ep8lfr09ort462bkaago5g" modified-by="lq_lab" timestamp="1552182464132"><title>Serial</title><children><topics type="attached"><topic id="0j92jga4kgkaobidmrds1v5imo" modified-by="lq_lab" timestamp="1552182436975"><title>单线程 + stop the world</title></topic><topic id="11gji2tp56p7fnjhc14m2nd0ri" modified-by="lq_lab" timestamp="1552181725648"><title>简单高效，单CPU情况下具有最高的单线程收集效率</title></topic><topic id="2c34orhhmbscngmdn9f4n32kpd" modified-by="lq_lab" timestamp="1552182361480"><title svg:width="500">client模式下默认新生代收集器，小内存情况下，垃圾收集停顿时间很小（但也有停顿）</title></topic></topics></children></topic><topic id="1jp6ikffkdo3mf3qpdvi6ocp40" modified-by="lq_lab" timestamp="1552182475591"><title>ParNew</title><children><topics type="attached"><topic id="4m1275q932sf0reic82os0b0ub" modified-by="lq_lab" timestamp="1552182433697"><title>多线程（Serial的多线程版本）+ stop the world</title></topic><topic id="19j0b4ud04lbcsonot765kq11s" modified-by="lq_lab" timestamp="1552181936170"><title>Server模式下默认的新生代收集器（选择原因：性能+能配合CMS）</title></topic></topics></children></topic><topic id="0e0kll6olklubmvc0cqd7s75es" modified-by="lq_lab" timestamp="1552183208699"><title>Parallel Scavenge</title><children><topics type="attached"><topic id="52r2oli7ko66iejdc9tlgpqg4h" modified-by="lq_lab" timestamp="1552182426401"><title>多线程 + stop the world</title></topic><topic id="1bjqlprd91kv4n821k0ahi6n7h" modified-by="lq_lab" timestamp="1552183208711"><title>特点</title><children><topics type="attached"><topic id="07jk99r97q90uj6l9tnfft4i88" modified-by="lq_lab" timestamp="1552183208700"><title svg:width="500">关注吞吐量（但是参数有虚拟机自行优化），就是用户代码运行时间的占比尽可能高</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6fs3gte4blqat7eeqkuldo307f" modified-by="lq_lab" timestamp="1552182865093"><title>老年代</title><children><topics type="attached"><topic id="158lpa87nlvltcle1ubv6dnfo4" modified-by="lq_lab" timestamp="1552183215515"><title>Serial Old(MSC)</title><children><topics type="attached"><topic id="1tl97ju2rq2sf8albte1ig1ovf" modified-by="lq_lab" timestamp="1552183099198"><title>单线程 + Serial收集器的老年代版本</title></topic><topic id="2v7iuocjbidv2nkmafjk6j82up" modified-by="lq_lab" timestamp="1552183073832"><title>用途</title><children><topics type="attached"><topic id="3fohhs53efekvk885d9k0ehul7" modified-by="lq_lab" timestamp="1552183066208"><title>jdk1.5 之前和parallel  Scavenge搭配使用</title></topic><topic id="1ntpofephlm71d6tqmu581f23n" modified-by="lq_lab" timestamp="1552183073824"><title>作为CMS的后备方法（并发收集发生Concurrent Mode Failure时）</title></topic></topics></children></topic></topics></children></topic><topic id="65llbh2qrlh7qnjhnjij6sa0dn" modified-by="lq_lab" timestamp="1552183129962"><title>Parallel Old</title><children><topics type="attached"><topic id="12jac4pifvdmu0int00v2ladgg" modified-by="lq_lab" timestamp="1552183126513"><title>单线程 + Parallel Scavenge收集器老年代版本</title></topic><topic id="6qunoc7ki2fugi1ad869c5is5r" modified-by="lq_lab" timestamp="1552183190317"><title>使用场景：注重吞吐量+CPU敏感的场合</title></topic></topics></children></topic><topic id="1ee06rk4msdh9g50kqpc72rf0g" modified-by="lq_lab" timestamp="1552183726396"><title>CMS</title><children><topics type="attached"><topic id="6ae7a3adhagvomdsbiho4dqr7k" modified-by="lq_lab" timestamp="1552182755197"><title>尽可能压缩停顿时间</title><children><topics type="attached"><topic id="7mcfs25k45otan3s7sset2bh6f" modified-by="lq_lab" timestamp="1552182816993"><title svg:width="500">通过牺牲吞吐量和新生代空间换取：新生代空间变小，垃圾回收频繁，吞吐量下降</title></topic></topics></children></topic><topic id="0ajqfrjkjvf10h4c3qu2mvfrrk" modified-by="lq_lab" timestamp="1552183509385"><title>并发收集（收集线程和工作线程同时运行）</title></topic><topic id="0lav68pmncfh1tdjc5rvaopc6d" modified-by="lq_lab" timestamp="1552183629640"><title>标记-清除算法实现</title><children><topics type="attached"><topic id="2nvivirnlk0djrkf7k056q5ke0" modified-by="lq_lab" timestamp="1552183667527"><title>1. 初始标识（停）</title><children><topics type="attached"><topic id="0ub9o0tu1ap7qtneg5nnoemn93" modified-by="lq_lab" timestamp="1552183550367"><title>暂停所有的其他线程，记录直接与root相连的对象（速度很快）</title></topic></topics></children></topic><topic id="3ptfugqbjks49ns5pp1sjfcmrb" modified-by="lq_lab" timestamp="1552183675710"><title>2. 并发标识（不停）</title><children><topics type="attached"><topic id="3kvlhmuntkr919alq79hr9vkkp" modified-by="lq_lab" timestamp="1552183585519"><title>同时开启GC和用户线程，用一个闭包结构取记录可达对象。由于用户线程会更新引用，所以需要记录更新的位置</title></topic></topics></children></topic><topic id="4jnvudvj2iunqi206bls452jhk" modified-by="lq_lab" timestamp="1552183686856"><title>3. 重新标记（停）</title><children><topics type="attached"><topic id="6seqcgu86f7k2e5afnuanda9tv" modified-by="lq_lab" timestamp="1552183622576"><title>停下所有用户线程（这个停顿的时间远比并发标识的时间少），修正并发标识期间修改的标识。</title></topic></topics></children></topic><topic id="0mauojuutbg6j1fl8p4mjn5iek" modified-by="lq_lab" timestamp="1552183692341"><title>4. 并发清除（不停）</title><children><topics type="attached"><topic id="5g5sdb40oefkfllmorfrdkgbge" modified-by="lq_lab" timestamp="1552183651840"><title>开启用户线程，同时GC开始对标记区域做清扫</title></topic></topics></children></topic></topics></children></topic><topic id="0ojv8estmtadlu4ro2uileo6lq" modified-by="lq_lab" timestamp="1552183724596"><title>优点</title><children><topics type="attached"><topic id="22k913tllccitlbqd7p39hih7h" modified-by="lq_lab" timestamp="1552183722061"><title>并发收集、低停顿</title></topic></topics></children></topic><topic id="03u6gjdi13n7ogc0dr4j3ii2td" modified-by="lq_lab" timestamp="1552183778303"><title>缺点</title><children><topics type="attached"><topic id="4kqth29v952boosnfcpj4lnhuu" modified-by="lq_lab" timestamp="1552183761177"><title>吞吐量低，对cpu资源敏感</title></topic><topic id="0ad4ji5vmqb53q785glbmjf6ja" modified-by="lq_lab" timestamp="1552183768003"><title>无法处理浮动垃圾</title></topic><topic id="6sh4khbvc7qodfdo80ekgeiiis" modified-by="lq_lab" timestamp="1552183775022"><title>回收算法采用“标记-清除”，产生大量碎片</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2rmam18qvvd1ep5aqq7rh7cmve" modified-by="lq_lab" timestamp="1552184238341"><title>G1</title><children><topics type="attached"><topic id="79q0qss2bg17m9hvt60jj3nh7l" modified-by="lq_lab" timestamp="1552184081305"><title>描述</title><children><topics type="attached"><topic id="1q7mmv8u640802uab9vc1g7ul6" modified-by="lq_lab" timestamp="1552183884858"><title>面向服务器（打算干掉CMS）</title></topic><topic id="63hf25aomq02b4jeil69ij9a1g" modified-by="lq_lab" timestamp="1552183906700"><title>适用于多CPU和大内存场景</title></topic><topic id="29b8n0qhi724lefgnes02nno46" modified-by="lq_lab" timestamp="1552183932768"><title>新/老年代都能收集</title></topic></topics></children></topic><topic id="27ahsplpq7toc9r7f5auenr60o" modified-by="lq_lab" timestamp="1552184000568"><title>特点</title><children><topics type="attached"><topic id="39431sp6ot81gqfs029n7u6dle" modified-by="lq_lab" timestamp="1552184003784"><title svg:width="500">- 并发与并行：充分利用多核资源，使得GC收集器和应用程序可以并发执行</title></topic><topic id="1a8gva3edgnoskc7uaqslo0cv5" modified-by="lq_lab" timestamp="1552183994114"><title>- 分代收集：不需要其他的收集器配合就能独立管理，但是依然保留分代概念</title></topic><topic id="3fo5pn8mppc6rl0nuj98qcncmr" modified-by="lq_lab" timestamp="1552183994114"><title>- 空间整理：从整体上看属于“标记-整理”，从局部上看数据“标记-复制”算法。</title></topic><topic id="1igsli5vu5rega83c1s3f2m1a2" modified-by="lq_lab" timestamp="1552184093686"><title>- 可预测的停顿：还能建立可预测的停顿时间模型，让使用者明确指定在一个长度为M毫秒的时间片段内</title><children><topics type="attached"><topic id="5tscaq5bsj9uvnt3blvp8odr5j" modified-by="lq_lab" timestamp="1552184231852"><title svg:width="500">引入的Region概念，灵活性增强，维护优先列表，优先收集价值最大的Region</title></topic></topics></children></topic></topics></children></topic><topic id="3ohsedirk9tuauc2mbgo82r9oq" modified-by="lq_lab" timestamp="1552184282991"><title>步骤</title><children><topics type="attached"><topic id="3rc80o64qcdum36t1ea42s85ft" modified-by="lq_lab" timestamp="1552184344451"><title>- 初始标记（停）</title></topic><topic id="4itg2ivfk03f5u5sq34dbbvifa" modified-by="lq_lab" timestamp="1552184349240"><title>- 并发标记（不停）</title></topic><topic id="1e1532a9750uvg4r0t586f0irh" modified-by="lq_lab" timestamp="1552184462779"><title>- 最终标记（停，但可不停）</title><children><topics type="attached"><topic id="0lcd8pjmp7bfufjje0adm88tcl" modified-by="lq_lab" timestamp="1552184436043"><title>修正因为并发导致的引用关系的变动</title></topic></topics></children></topic><topic id="1urqktlc25is58em3hnm1tr6r4" modified-by="lq_lab" timestamp="1552184463528"><title>- 筛选回收（停，但可不停，但是时间可控，停性能更好）</title><children><topics type="attached"><topic id="0kpvh8rkd4rrr4dqal3camp3rt" modified-by="lq_lab" timestamp="1552184505228"><title svg:width="500">对各个Region的价值和回收成本排序，根据用户期望的停顿时间指定回收计划</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6ld2b0a3auev5toj2955dfbrsg" modified-by="lq_lab" timestamp="1552186755438"><title>堆内存</title><children><topics type="attached"><topic id="3svk1car6opj2nfqgv4g411gep" modified-by="lq_lab" timestamp="1552186325754"><title>内存示意图</title><children><topics type="attached"><topic id="3gtdfterd1joqspaqfsd1ic7uv" modified-by="lq_lab" timestamp="1552186405747"><title svg:width="500">新生代（Eden + S1 + S2） + 老年代（Old Generation） + 永久代（Perm，java1.8中换成了元空间）</title></topic></topics></children></topic><topic id="7ijdfq0edbmfpph07hid51h5qq" modified-by="lq_lab" timestamp="1552186449190"><title>堆内存分配策略</title><children><topics type="attached"><topic id="2gcpmsf7n1t4dc5g18ubdibkk0" modified-by="lq_lab" timestamp="1552186438286"><title>对象优先在Eden区</title></topic><topic id="3vrgb9o7rd2dskmmp5jrsp6nb0" modified-by="lq_lab" timestamp="1552186599445"><title>大对象直接进入老年代</title><children><topics type="attached"><topic id="70jdd9oc0i3hu2moga6npjtl2g" modified-by="lq_lab" timestamp="1552186599436"><title>-XX:PretenureSizeThreshold</title></topic></topics></children></topic><topic id="2fgppdu710ql3pt9gmfqjtha52" modified-by="lq_lab" timestamp="1552186625653"><title>长期存活对象将进入老年代</title><children><topics type="attached"><topic id="2kedq4dm8dovh3dfe1r8qkftt0" modified-by="lq_lab" timestamp="1552186607116"><title>-XX:MaxTenuringThreshold </title></topic><topic id="65ila14nlkortumtmfuqc4edmt" modified-by="lq_lab" timestamp="1552186632645"><title>动态年龄判断</title><children><topics type="attached"><topic id="3plud3jrbro6drcqvf5bch0stl" modified-by="lq_lab" timestamp="1552186684091"><title>相同年龄对象总和大于一半时，则大于这个年龄的直接进老年代</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="2kpvfl60vcermt28tpap7pnn56" modified-by="lq_lab" timestamp="1552186702005"><title>分配担保：</title><children><topics type="attached"><topic id="54q4afgmlo7q7jd6nevjvk4bek" modified-by="lq_lab" timestamp="1552186749559"><title svg:width="500">Minor GC时无法将对象放入Survivor区，把新生代对象提前转移到老年代中</title></topic></topics></children></topic><topic id="4j3v7h68che2ts2a12l61qvfk3" modified-by="lq_lab" timestamp="1552186832706"><title>两种GC</title><children><topics type="attached"><topic id="420bl92e6eabtqpk61li712mho" modified-by="lq_lab" timestamp="1552186856987"><title>新生代GC(Minor GC)</title><children><topics type="attached"><topic id="7k9kubmbq6epdrua81254r1p03" modified-by="lq_lab" timestamp="1552186856976"><title>指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</title></topic></topics></children></topic><topic id="735tr6rgbbu7e8m3jb951ntdjk" modified-by="lq_lab" timestamp="1552186876134"><title>老年代GC(Major GC/Full GC)</title><children><topics type="attached"><topic id="60fqjhv2umteg7psdk6731kc7s" modified-by="lq_lab" timestamp="1552186862304"><title>指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上</title></topic><topic id="3b8tm4dta38kfq9qv70sgq1u67" modified-by="lq_lab" timestamp="1552187168390"><title>触发条件</title><children><topics type="attached"><topic id="57rpa0c3o3p13li2k9oc6tlfkl" modified-by="lq_lab" timestamp="1552186926807"><title>调用System.gc()，此时建议进行，但不一定进行</title></topic><topic id="3cdrfvl6s7cn6d59gepj2lqnkk" modified-by="lq_lab" timestamp="1552187037928"><title>老年代空间不足（大对象进入、或者长期存活对象进入时可能发生）</title></topic><topic id="787g96ioncpc1n5lckq2c81sf9" modified-by="lq_lab" timestamp="1552187047366"><title>空间分配担保失败</title></topic><topic id="5ju2qa4ltlvq9hcps4rak613m1" modified-by="lq_lab" timestamp="1552187129654"><title>JDK1.7以前的永久代空间不足</title><children><topics type="attached"><topic id="26ches5v0fmu8asasopbn3bhfo" modified-by="lq_lab" timestamp="1552187155494"><title>可以通过增大永久代或者使用CMS GC</title></topic></topics></children></topic><topic id="5dniois19mrn20siirqu02vh2d" modified-by="lq_lab" timestamp="1552187189686"><title>Concurrent Mode Failure</title><children><topics type="attached"><topic id="3rmsk6memmcb7gdgckf8b631b2" modified-by="lq_lab" timestamp="1552187231579"><title svg:width="500">发生的情况：CMS GC的过程中有对象要放入老年代，而此时老年代空间不足</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7tpmhf7jmtiv4c1vmvd91o6tap" modified-by="lq_lab" timestamp="1552187743592"><title>对象已经死亡？</title><children><topics type="attached"><topic id="1jnbhjukji5gf5q3vrrtoflsvu" modified-by="lq_lab" timestamp="1552187502020"><title>判断方法</title><children><topics type="attached"><topic id="17guo36f124lv25uj8bgc3mape" modified-by="lq_lab" timestamp="1552187501738"><title>引用计数法</title></topic><topic id="702br89675vut787cb5kbrmu6m" modified-by="lq_lab" timestamp="1552187507944"><title>可达性分析</title></topic></topics></children></topic><topic id="3t8fmuds59vl2bmv106mrtv2js" modified-by="lq_lab" timestamp="1552187790678"><title>GC Roots</title><children><topics type="attached"><topic id="0ic2hj7s2aj1vfngpv029jnjrd" modified-by="lq_lab" timestamp="1552187635100"><title>虚拟机栈中局部变量表中引用的对象</title></topic><topic id="0s4vo52gsur87vgermbp2sqh3u" modified-by="lq_lab" timestamp="1552187635100"><title>本地方法栈中 JNI 中引用的对象</title></topic><topic id="6ljflr4s01jpjdd1gu9d6sibae" modified-by="lq_lab" timestamp="1552187635100"><title>方法区中类静态属性引用的对象</title></topic><topic id="1cqe4kmc3ac0dufvd9t0n9vilu" modified-by="lq_lab" timestamp="1552187635100"><title>方法区中的常量引用的对象</title></topic></topics><topics type="summary"><topic id="7q2vc1v7vhfvjtvv4v1lc6elok" modified-by="lq_lab" timestamp="1552187850060"><title>具体而言</title><children><topics type="attached"><topic id="6eht66nid7u485fiie6jqou4u7" modified-by="lq_lab" timestamp="1552187850014"><title>由系统类加载器（BootStrap）加载对对象（Class）</title></topic><topic id="14p1ej9e2ipapmk8uvimmttg7g" modified-by="lq_lab" timestamp="1552187850014"><title>活着的线程</title></topic><topic id="25blsl2pt8fkknebkappggu6m6" modified-by="lq_lab" timestamp="1552187850014"><title svg:width="500">java方法的local变量或参数（理解，这些一旦存在说明方法正在被调用，这些不能回收，方法运行完能自动回收）</title></topic><topic id="74670ma4cjt2o3or04v3mgh3vm" modified-by="lq_lab" timestamp="1552187850014"><title>JNI方法的Local变量或参数</title></topic><topic id="5suci9b2ni3rsutqog8p8km2gr" modified-by="lq_lab" timestamp="1552187850014"><title>JNI全局引用</title></topic><topic id="64fiav6n5ni1bp0cf0ktnnje6r" modified-by="lq_lab" timestamp="1552187850014"><title>用于同步的监控对象</title></topic><topic id="51idodicocoe5ohba6b49jm628" modified-by="lq_lab" timestamp="1552187850014"><title svg:width="500">Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的</title></topic></topics></children></topic></topics></children><summaries><summary id="3err7cud98t8ro7b7qapou8rj0" modified-by="lq_lab" range="(0,3)" timestamp="1552187790569" topic-id="7q2vc1v7vhfvjtvv4v1lc6elok"/></summaries></topic></topics></children></topic></topics></children><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>4</right-number></content></extension></extensions></topic><title>画布 1</title></sheet></xmap-revision-content>