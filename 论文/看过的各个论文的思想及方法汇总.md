# Multimodal Network Alignment看过的各个论文的思想及方法汇总

### Blind De-anonymization Attacks using Social Networks
> Lee, Wei-Han, Changchang Liu, Shouling Ji, Prateek Mittal and Ruby B. Lee. “Blind De-anonymization Attacks using Social Networks.” _WPES@CCS_ (2017).

- 阐述当前基于种子的缺点
- 所使用的特征：采用邻居度数分布直方图，1跳邻居度数直方图，2跳邻居度数直方图（这里的直方图的使用可以等价转为设定划分的段数，然后求解每个段内所占的比例，拼接成为向量）
- 使用多跳信息、受欢迎程度PS、结构相似度作为结构得分（SS），分别计算两个网络中的SS，各选取前N个，通过计算特征向量的的余弦相似度，选取相似度前N对作为正例后N对做为负例。
- 训练PRF-SVM模型，并根据输出调整相似度

***

### COSNET: Connecting Heterogeneous Social Networks with Local and Global Consistency.
> 	Yutao Zhang, Jie Tang, Zhilin Yang, Jian Pei, Philip S. Yu: COSNET: Connecting Heterogeneous Social Networks with Local and Global Consistency. KDD 2015: 1485-1494
>
> 		本文的中心思想：综合考虑网络属性的相似度，匹配图中的结构相似度（PGM: percolation graph matching）以及多个网络中的匹配一致性，采用能量模型对其进行优化。

**启示：** 对所有可用的特征进行建模得到得到特征的表示方法，之后寻找办法这些抽取出来的特征想办法揉入到目标函数中，一些与匹配相悖的特征也是具有意义。借鉴机器学习中的理论进行处理。

***

### Link Prediction in Complex Networks: A Survey.
> Lu, Linyuan and Tao Zhou. “Link Prediction in Complex Networks: A Survey.” _CoRR_abs/1010.0725 (2010): n. pag.
- 基于局部特征的预测方法
- 基于全局特征的方法
  注：由于方法实在是太多，在此不再一一详细地列出

***

### An Automated Social Graph De-anonymization Technique.
> Sharad, Kumar and George Danezis. “An Automated Social Graph De-anonymization Technique.” _WPES_ (2014).

- 针对电话通话网络问题，原始的数据被处理为 ego network（数据具有自己的特殊性，抽取的方法是选中点后抽取其邻居以及邻居的邻居生成网络）
- 仅使用节点的度数信息，将节点度数按照逐级递增的方式划分至各个容器中形成向量中（直方图的思想），使用决策树训练得到模型

***

###  Community-Enhanced De-anonymization of Online Social Networks
> Nilizadeh, Shirin, Apu Kapadia and Yong-Yeol Ahn. “Community-Enhanced De-anonymization of Online Social Networks.” _ACM Conference on Computer and Communications Security_ (2014).

论文具体的步骤：
1. 使用 Infomap algorithm算法划分社区
2. 进行种子社区匹配识别，种子社区匹配识别方法比较简单，就根据当前的社区内部的种子用户的对应情况来进行划分，需要解决一下冲突问题（在一个网络中在一个社区中的种子用户在另外的一个网络划分的社区中不在一个社区中），如果是多对一,使用匹配最多的，如果是一对多，随机选择一个。
3. 建立由原始的网络建立社区之间的联系，之后将社区看成是一个用户点使用NS算法进行社区识别。
4. 社区内部用户识别，当通过聚集系数和度数计算的两个距离判断标准足够相似并且大于指定的阈值使认为两个节点匹配。
5. 在全局范围内使用NS算法进行识别

NS算法：
1. 种子识别，
2. 通过共同邻居的匹配数来进行识别匹配。选择相似度显著大于次相似的用户对。 相似度的计算公式如下所示：
    ![](https://s1.ax1x.com/2018/12/06/FlvS10.png)

***

### Community-Based Network Alignment for Large Attributed Network
> Chen, Zheng, Xinli Yu, Bo Song, Jianliang Gao, Xiaohua Hu and Wei-Shih Yang. “Community-Based Network Alignment for Large Attributed Network.” _CIKM_ (2017).
> ** 太难了，算是没有看懂，如果有需要回头来继续好好看 **
- 将用户匹配识别模型转化为能量模型进行处理，其中能量模型共由三个部分组成：本地匹配相似度（即根据某些相似度计算的匹配）、网络匹配相似度（边的匹配情况）和全局相似度组成（这里假设只有三种网络，是否形成环以及里面的各种情况）
- 网络匹配图概念：从不同的两个网络中各任取一个节点形成新的节点，新节点之间的联系通过判断新节点中相同位置的元素是否互为邻居进行创建。
- 针对网络匹配图的剪枝策略（仅保留有可能的候新节点）：基于内容进行剪枝，基于结构进行剪枝，或者混合两种方法。
- 提出的模型算法：
1. 首先使用最大边界理论提出用户识别在这种方法下的优化目标。
2. 重写限制条件后得到未知参数的表达，用于替换目标函数中的未知变量。
3. 使用拉格朗日松弛算法将原始的目标函数划分为一系列比较容易求解的子问题。
4. 使用对偶分解法（引入拉格朗日乘子lamda）
5. 经过一系列化简后原问题可以使用[projected sub-gradient](https://blog.csdn.net/yiqingyang2012/article/details/78317415) 算法来进行求解。
    ** 核心 ** 提出能量模型，同时考虑全局一致性，以及一个完整和严谨问题定义以及求解方法。

***

###  De-anonymizing social graphs via node similarity
> Fu, H. , Zhang, A. , & Xie, X. . (2014). De-anonymizing social graphs via node similarity.

本文提出一种不断迭代更新二部图中的匹配相似度的方法来进行识别。具体的识别方法如下所示：
- 首先初始相似度置为1，代表确定i, j的邻居集
- 构建完全二部图，边的权重为当前阶段i'， j'的相似度(注意这里的i'和j'分别代表i，j邻居集中的点)
- 寻找映射中的最大匹配对
- 根据公式更新相似度
  其中，可以将图划分为简单图和复杂图，两种图结构中不同的是含有的信息存在差别（复杂图中含有节点相似度、边相似度等多种信息，而简单图中仅包含边的相似度信息），从而导致相似度的更新公式存在差别。
  简单图的相似度更新公式：Theta代表取匹配操作，即从网络2中取出l对应的用户节点。
  ![简单图相似度更新公式](https://s1.ax1x.com/2018/12/08/F8VFsg.png)
  复杂图的相似度更新公式：S(0)为节点的属性相似度，SR为有向图中边的相似度，SX为节点属性相似度
  ![复杂图的相似度更新公式](https://s1.ax1x.com/2018/12/08/F8V0yD.png)
** 本文的核心思想 ** 基于每对候选匹配对的邻居匹配情况来不断对当前匹配的置信度（相似度）进行更新迭代，在每次迭代的过程中选择前top相似度作为匹配，可以在不断迭代的过程逐渐识别出更多的点。
** 存在的问题 ** 时间复杂度高，不适合大型网络（但是可以做，只是比较费时间而已）。

***

### De-anonymizing social networks and inferring private attributes using knowledge graphs.
>  Qian, Jianwei, Xiang-Yang Li, Chunhong Zhang and Linlin Chen. “De-anonymizing social networks and inferring private attributes using knowledge graphs.” _IEEE INFOCOM 2016 - The 35th Annual IEEE International Conference on Computer Communications_(2016): 1-9.
>  论文中主要思想：
1. 用户识别阶段
- 将攻击者具有的知识使用知识图谱进行表示（主谓宾）。
- 使用属性相似度（知识相似度）：感觉有点类似于极大似然估计。
- 使用结构相似度：出度、入度、n跳邻居的杰拉德相似度
- 将两种相似度进行加权求和得到最后的的相似度
- 根据攻击者具有的网络用户数量少这个特征进行优化，为辅助网络中的每个节点选出k个候选节点，从而能够将完全的二部图匹配转化为非完全的二部图匹配，降低空间和时间复杂度。
2. 知识推理阶段
- 使用page rank算法以及逻辑回归进行知识的推理，比如更新某些知识的权重

***

### De-anonymizing social networks: Using user interest as a side-channel.
> Lai, Shuying, Huaxin Li, Haojin Zhu and Na Ruan. “De-anonymizing social networks: Using user interest as a side-channel.” _2015 IEEE/CIC International Conference on Communications in China (ICCC)_ (2015): 1-5.

本文的算法可以看成是对NS算法和基于社区的NS算法的一个优化方法，选出社区内部中影响力最大用户提取其兴趣作为社区的标签（每个组可以具有n个标签），从而利用兴趣信息来提高识别的性能。
- 识别方法：还是基于传播的方法（和NS算法特别像），基于一个假设，不同的网络中具有相似的社交结构（换言之，如果当前两个节点（A、B）已经匹配上，某点（A）的邻居一般会匹配到对应点（B）的邻居中）
- 其中关于结构相似度和兴趣相似度的组合方式没有具体的提及，但本人认为可以是简单的加权即可。

***

### De-Anonymizing Social Networks With Random Forest Classifier
> Ma, Jiangtao, Yaqiong Qiao, Guangwu Hu, Yongzhong Huang, Arun Kumar Sangaiah, Chaoqin Zhang, Yanjun Wang and Rui Zhang. “De-Anonymizing Social Networks With Random Forest Classifier.” _IEEE Access_ 6 (2018): 10139-10150.

本文构建基于Degreee centrality、Clustering Coefficient、Eigenvectors Centrality三个度量标准构建特征向量，将问题转化为分类问题，如果输入匹配则看成是正例，否则看成是负例。
方法：
![识别流程](https://s1.ax1x.com/2018/12/10/FGc85F.png)
三种特征的计算公式：
![三种特征的计算公式](https://s1.ax1x.com/2018/12/10/FGct29.png)
其中的k代表邻居节点的个数，或者就可以理解为节点的度数。

***

### De-anonymizing Social Networks
> Narayanan, Arvind and Vitaly Shmatikov. “De-anonymizing Social Networks.” _2009 30th IEEE Symposium on Security and Privacy_ (2009): 173-187.

算法的思想比较简单：基于邻居中已经匹配的个数来进行识别
- 首先识别种子节点，关于种子节点的识别方法不是重点，只是识别方法的好坏影响着最终的结果。
- 从种子节点的邻居开始识别，识别相似度的计算公式为每增加一个已经匹配过的邻居（即邻居对应匹配到别人的邻居里）则在得分上加上一个值（这个值可以是简单的加一，也可以是倒数的均方根分之一，后者可以在一定程度解决方法优先选择度数较大节点的缺点），之后选取相似度最大且显著次最相似有显著的差距的才能选中
- 为了提高识别的准确度，互换辅助网络和目标网络，当且仅当正向匹配和反向匹配都是一致时才认为是匹配的。
- 迭代上面的过程，直到识别不出更多节点。

其中具有一个可以优化策略：刚开始时识别的准确率比较低，可以在识别出一定的节点后再回来识别已经识别的节点。

### De-anonymizing Web Browsing Data with Social Networks
> Su, Jessica, Ansh Shukla, Sharad Goel and Arvind Narayanan. “De-anonymizing Web Browsing Data with Social Networks.” _WWW_ (2017).

提出一种生成模型，即根据已经有的访问过的链接，根据极大似然找出最可能的情况。具体没有仔细地看。

***

### Friend in the Middle (FiM): Tackling de-anonymization in social networks.
> Beato, Filipe, Mauro Conti and Bart Preneel. “Friend in the Middle (FiM): Tackling de-anonymization in social networks.” _2013 IEEE International Conference on Pervasive Computing and Communications Workshops (PERCOM Workshops)_ (2013): 279-284.

本文的主要思想是提出一种匿名保护算法，其中定义一个中间朋友的概念（Friend in the middle），所谓的中间朋友就是另外的用户通过中间用户进行连接，如果将中间朋友信息保存在第三方可信平台上的话那么识别的难度会大大地增强。

**启示：**如何利用中间信息是一个可以深入研究的切入点。

***

### Hybrid de-anonymization across real-world heterogeneous social networks.
> Li, Huaxin, Qingrong Chen, Haojin Zhu and Di Ma. “Hybrid de-anonymization across real-world heterogeneous social networks.” _ACM TUR-C_ (2017).

本文的主要思想为：
- 首先提出通过网络的结构能够减少匹配候选者（选出候选者）
- 其次通过用户的属性进行高精度的匹配（进行匹配）
  具体的算法为：
- 使用infomap算法进行社区的划分
- 基于社区内部用户名相同的节点个数进行社区的匹配
- 在社区内部基于用户名使用Monge-Elkan算法计算用户名相似度进行匹配识别。
  Monge-Elkan算法的大概原理如下所示：
  ![Monge-Elkan算法的大概原理](https://s1.ax1x.com/2018/12/10/FGvfUO.png)
  其中Jaro-Winkler相似度的计算公式见[博客](https://blog.csdn.net/frone/article/details/80080850)的讲解。

***

###  大数据时代中的去匿名化技术及应用[J].信息通信技术
> 孙广中,魏燊,谢幸.大数据时代中的去匿名化技术及应用[J].信息通信技术,2013,7(06):52-57.

这是一篇综述性的文章。
匿名方法：
-	扰动和泛化
    扰动：对正确数据做一些变换
    ​	泛化：在一定范围内选择新值将旧值替换
-	K匿名化和I多样化
    K匿名化：每个标识符至少对应K个实例
    ​	I多样化：在K匿名基础上相同标识符在敏感值上具有I个值
-	分布式隐私保护
    分割后发布（进行水平、垂直分片）
-	降低数据挖掘结果的效果
    隐藏某些关联规则或者轻微该表分类模型保护隐私
-	差分隐私保护
    添加噪声，确保删除或添加一个数据集中的记录并不会影响分析结果
    去匿名化方法：
-	针对推荐系统评分数据的去匿名化: 选择相似度最高的作为结果
-	针对图结构数据的去匿名化
  1. 基于映射的方法：种子的识别、扩散
  2. 基于猜测的方法:窃取浏览器cookie，猜测ID
-	针对文本数据的去匿名化：文法分析、机器学习分类
    **其中利用更多的推荐系统方面的知识是一个研究比较少的方法，可以在这个方面上进行研究**

***

###  基于信息熵的跨社交网络用户身份识别方法
> 吴铮,于洪涛,刘树新,朱宇航.基于信息熵的跨社交网络用户身份识别方法[J].计算机应用,2017,37(08):2374-2380.

本文的主要思想是：**利用各种属性计算相似度，并计算出每种属性的熵值，并利用熵值的倒数作为权重**
所用的属性已经相似度计算方法：
- 用户名：采用MN（Matching Name）算法，首先是用户名进行预处理，将用户名中含有的特殊字符或者表情删除，然后将精确匹配与部分匹配结合，得到最终的匹配值。
- 自我描述：利用TF-IDF模型进行处理
- 兴趣爱好：构建标签词袋
- 网页链接：直接判断是否相同，如果相同则为1，不同为0
- 地理位置：使用大圆距离，具体的计算公式如下所示
  ![FJjyZV.png](https://s1.ax1x.com/2018/12/11/FJjyZV.png)
- 头像：分别利用感知哈希算法(Perceptual Hash Algorithm， PHA)技术和尺度不变特征 变换(Scale-Invariant Feature Transform，SIFF)算法进行识别，前者通过比较图片的指纹确定相似度，后者通过比较局部特征来比较相似度。

权重的计算：
![FYSJyj.png](https://s1.ax1x.com/2018/12/11/FYSJyj.png)

识别的过程为：
- 账号选择，通过用户名进行过滤选择
- 账号匹配，
- 剪枝过滤
  **启示：** 这里面的权重的计算方式比较新奇，或许可以使用。

***

### 社交网络分析中的隐私保护问题：去匿名化与无缝隐私
> 丁旋. 社交网络分析中的隐私保护问题：去匿名化与无缝隐私[D].清华大学,2014.

主要的思想：针对一个网络的多个动态的发布版本，构建贯穿（对于某个用户在不同集合中组成的序列）组成惯射（不相交的贯穿），然后拓展贯射，基于拓展后的贯射利用结构和属性相似度进行识别匹配（利用离心率减少假阳性）。

论文中阐述了无缝隐私（数据库固定时，相近的查询得到相近的结果）和差分隐私（查询函数固定时，在相近的数据库上产生相近的回复）的关系。

论文中其实和全局一致的匹配方法比较相似，并且方法中要求具有很强的全局映射，对于多个异构网络的识别可能会导致性能不好。节点的匹配是传统的基于相似度的方法，为了寻找匹配需要在整个网络中去查找最合适的匹配点，使用的特征包括：已经匹配上的邻居节点已经节点的公共属性。

###  社交网络高效高精度去匿名化算法
> 刘家霖,史舒扬,张悦眉,邵蓥侠,崔斌.社交网络高效高精度去匿名化算法[J].软件学报,2018,29(03):772-785.

主要思想：提出一种不使用种子信息的识别方法，在这种方法中迭代地更新相似度，直到相似度达到稳定的状态。在匹配的阶段利用当前的匹配信息不断地更新相似度，达到在识别的过程中利用中间识别结果。

具体的过程如下图所示：
![迭代算法1](https://s1.ax1x.com/2018/12/11/FYu1hQ.png)
其中：
![FYubut.png](https://s1.ax1x.com/2018/12/11/FYubut.png)
1. 初始化所有的相似度为1,
2. 计算所有的匹配对的相似度更新相似度矩阵，时间复杂度为两个网络节点个数的乘积
3. 迭代直到到达指定的轮数
    这个方法存在一个问题：对于不相似的部分再怎么更新也是不相似，反而会影响实验的结果。所以一种简单的策略为选取其中的相似度大于alph*topSim的才进行更新。具体实现就是下一个算法：

另外的一个快速版本为：
![FYua7T.png](https://s1.ax1x.com/2018/12/11/FYua7T.png)
1. 初始化所有的相似度为1
2. 对于网络1中的每个用户找出其与网络2中的最大的相似度，选取相似度大于alph*topSim的用户匹配对进行相似度更新
3. 迭代更新直到达到指定的轮数

识别的过程：
在识别的过程中同时输出最相似度的匹配对，同时将当前匹配对的邻居匹配对加上当前匹配点对的得分。

**启示：**这个算法中的相似度更新方法比较易于接受，可以将这个方式用到其他的地方。此外
，利用中间识别方法的思想比较奇特（本质上和邻居已经匹配那么当前匹配对可以加分）。还有**剪枝**

***

### 社交网络中匿名个体识别技术研究和展望
> 好像是自己写的，哈哈，自己曾经这么牛皮？？？，最近干吗呢？划水？！！

具体的内容就不贴了，大概的思想就是总结了一下常用的四类方法：
- 基于结构
- 基于内容
- 基于属性
- 基于混合特征

***

### 一种基于结构及节点特征相似度的社交网络图数据去匿名方法
> 王照永,陈勤,朱宏林,冯世杰.一种基于结构及节点特征相似度的社交网络图数据去匿名方法[J].现代计算机(专业版),2018(04):14-20.

 主要思想：使用网络的全局结构特征：K距离（距离领域内度数第k大节点的最短距离）和抽样近似距离（抽样出一个节点的子集后，子集中节点到当前节点距离的倒数之和）以及局部结构特征：度（节点的度数）和领域（邻居（几跳就不一定咯）按照大小排列后形成的向量）提出结构相似度计算公式，之后在提出属性相似度的计算公式，将两个相似度进行加权求和得到最终的相似度计算公式，之后选取相似度最大的匹配对。

其中相似度的计算公式：
- 结构相似度
  ![结构相似度](https://s1.ax1x.com/2018/12/11/FYllbq.png)
  其中c1,c2,c3为三个参数，并且和为1
  s(.)代表余弦距离
  d为度数
  c为抽样近似中心距离
  n为beta维的向量，向量内的值为节点领域内的度数最大的beta个邻居的度
  l为k个 k距离
  d,c(i) 组成一个向量，所以式中第一项中实际上输入两个两维向量
- 属性相似度
  ![属性相似度](https://s1.ax1x.com/2018/12/11/FYlwrR.png)
  感觉有点像属性是否存在的最大似然估计

**启示** 全局特征相似度是一个可以借鉴的属性。

***

### Cross-Platform Identification of Anonymous Identical Users in Multiple Social Media Networks.
> Zhou, Xiaoping, Xun Liang, Haiyan Zhang and Yuefeng Ma. “Cross-Platform Identification of Anonymous Identical Users in Multiple Social Media Networks.” _IEEE Transactions on Knowledge and Data Engineering_ 28 (2016): 411-424.
> 2018-12-12 重新整理
> 下一篇论文的先导

主要思想：其实和NS算法都是一类比较接近的方法，只是种子的被当成一个阶段的产物，更加的泛化，与NS算法不同的是在每个迭代过程中的识别方法不同，这个地方也是可以进行优化和创新的地方。识别方法主要基于当前用户的朋友的匹配情况。
具体如图：
![FtkZWt.png](https://s1.ax1x.com/2018/12/12/FtkZWt.png)

**Preprocessor**先验知识（种子）的获取：
- 基于邮箱，隐私信息，难以获取
- 基于用户名，大型网络中，重复率比较高
- 基于用户自己公开展示的社交关系绑定（例如在某个社交网络上展示其在另外社交网络上的账号）
  **Identifier（需要注意的是这是一类通过已经匹配的邻居来进行匹配的一类算法）**：
- NS算法优先选择度数较大的点，但是会造成没有优先选择最相似的节点进行匹配。在稀疏的网络中会丢失真实的匹配用户对。
  ![FtE0i9.png](https://s1.ax1x.com/2018/12/12/FtE0i9.png)
  其中d为节点的度数，c为共同邻居的个数。
- JLA考虑节点的朋友关系：
  ![FtEaa4.png](https://s1.ax1x.com/2018/12/12/FtEaa4.png)
  其中W为求集合中节点度数的倒数之和。节点数比较少容易造成匹配不是那么精确。
- FRUI 使用共同的朋友数，同时加入已经匹配的用户的相似度来解决潜在的冲突问题。 
  ![FRUI中使用的相似度](https://s1.ax1x.com/2018/12/12/Ft8vHs.png)
  并且在算法中通过计算解决冲突和不解决冲突两种的相似度来进行综合选择识别点，在识别的过程中不需要加入阈值参数进行控制，提高算法的性能。

提出两个定理：（其实这个可以作为NS算法的矩阵形式的理解）**这个矩阵的理解很重要**
1. 两个网络中节点和已经识别节点组成的邻接矩阵（分别记为$$Q_A 和 P_B$$）的乘积等于节点和已经识别节点的连接矩阵。
    具体的形式为：(mxk) x (kxn) = (mxn)其中的k为已经识别节点的个数
2. 可以通过增量更新的模式来进行识别。
    最简单直观的理解就是k的值增加deta k，对于两个矩阵分别增加 deta k行或 deta k列。
    具体实例为：
    ![FtfFxO.md.png](https://s1.ax1x.com/2018/12/13/FtfFxO.md.png)

**启示**这个矩阵的形式比较牛皮，可以对其进行拓展使用。
**存在的致命问题** 由于图的同构性，刚开始时识别的准确率比较低。

***

### Structure Based User Identification across Social Networks.
> Zhou, Xiaoping, Xun Liang, Xiaoyong Du and Jichao Zhao. “Structure Based User Identification across Social Networks.” _IEEE Transactions on Knowledge and Data Engineering_ 30 (2018): 1178-1191.
> 2018-12-12 重新整理阅读

主要思想：利用朋友关系（context）,朋友关系通过随机游走产生。主要分为两个步骤实现：第一步为利用**深度学习（Word2Vec）**得到节点的朋友关系向量表示，第二步利用朋友关系向量进行用户的识别。

节点朋友关系向量的生成过程：
1. 通过随机游走得到一个长度为l的遍历序列，对于序列中的除去第一个和最后一个节点外的所有节点取其前一个节点和后一个节点作为节点的上下文与当前节点组成正例，负例的的构建就比较简单了将当前的节点换为其他的节点可（最简单的是换为上下文中节点，这样能保证不存在冲突）
2. 使用自然语言处理中基于负例抽样的CBOW模型得到训练模型。模型过于复杂。
    **注意** 经过训练之后会产生一个朋友表示向量，这个就不仅仅是上面的二维向量了，是一个很长的向量。

基于朋友关系向量的用户识别方法：
在得到节点的向量表示后可以使用欧几里得距离、余弦相似度等进行相似度度量。
每个节点具有t个朋友关系向量，本文提出一种组合的方案，感觉就是所有向量可能的组合而已。

基于结构的方法：
- 具有种子信息的情况
4. 有监督
    PALE[26]: 基于节点表示（或者说子图嵌入）得到节点的隐性表达
    DCIM[27]: 结合结构信息和兴趣信息
5. 无监督
    **与其他方法最大的不同是：节点的相似度计算是基于已经匹配的节点**
- 不具有种子信息的情况
  NM[36]： 初始化所有的相似度为1，之后进行迭代的更新K次，最后在这个匹配矩阵中实现一对一匹配。迭代的时间复杂度为O(n^2  d ^3), 其实接近于n的五次方，并且对于重叠度不保证的情况下，算法的性能不能够得到保证。

子图嵌入：
- DeepWalk[47] : 随机游走
- Node2Vec[48] ：带偏执的随机游走
- LINE[49]：使用1st  order  proximity  and  2nd  order  proximity
- TriDNR[50]：综合考虑节点结构、节点内容、节点标签进行学习

***

### A Hybrid Model for Linking Multiple Social Identities Across Heterogeneous Online Social Networks.
> Kokkos, Athanasios, Theodoros Tzouramanis and Yannis Manolopoulos. “A Hybrid Model for Linking Multiple Social Identities Across Heterogeneous Online Social Networks.” _SOFSEM_ (2017).
> 2018-12-12 第一次阅读

主要思想：本文是一篇基于在线识别的方法，默认识别者拥有当前需要识别者的邮箱、图片、朋友关系、用户名、签名等各种属性，首先通过邮箱进行在线识别，如果失败则采用比较图片的相似度是否大于指定的阈值，如果大于指定的阈值，那么也是匹配，如果还不大于则计算余下属性的相似度并进行加权求和，如果相似度大于指定的阈值则认为是匹配的。

**核心**攻击者拥有被攻击者的具体信息，并且通过主动攻击的方式进行在线识别。可问题是如何得到具体的信息，以及如何进行在线查询等都是不方便进行的操作。

###  HYDRA: large-scale social identity linkage via heterogeneous behavior modeling
> Liu, Siyuan, Shuhui Wang, Feida Zhu, Jinbo Zhang and Ramayya Krishnan. “HYDRA: large-scale social identity linkage via heterogeneous behavior modeling.” _SIGMOD Conference_ (2014).
> 2018-12-12 第一次阅读

本文的主要思想：综合考虑了网络的行为特征和结构特征来进行用户的识别，其中使用的行为特征包括：计算属性的相似度并且由具体的训练数据集中每种正例个数作为其权重值，将用户的多个话题按照时间划分到多个桶中得到相似度向量，综合在考虑存在时间差的各个网络中用户位置和发布的图像一致性。为了能够利用矩阵相似度，计算各个匹配对之间的社交亲密度得到相似度矩阵M，对角的位置为当前用户行为相似度，非对角位置为匹配对之间的亲近程度。得到两类相似度Fd：行为相似度，Fs结构相似度。在具有C个网络的情况下，两两网络匹配能够有C*(C-1)/2种匹配情况，即具有C*(C-1)/2个Fs相似度。行为相似度用**SVM模型**进行训练得到分类模型，结构相似度使用使其匹配后的相似度最大的方法进行处理，为了让两者具有共性，将结构相似度最大的目标函数转化为求最小。每个目标函数看成是一维优化目标最后使用多目标优化方法对其进行识别。

具体过程：
行为相似度：
![FBTCuj.png](https://s1.ax1x.com/2018/12/19/FBTCuj.png)
结构相似度：
![FBTAU0.png](https://s1.ax1x.com/2018/12/19/FBTAU0.png)
终极目标函数：
![FBTZCT.png](https://s1.ax1x.com/2018/12/19/FBTZCT.png)
训练模型：
![FBTnv4.png](https://s1.ax1x.com/2018/12/19/FBTnv4.png)
其中K为核函数对应的矩阵，通过不断的训练学习得到模型的参数（需要注意的是这个后面还有一个复杂的模型求解目标函数的过程），对于以后的识别判断就通过这个模型进行识别即可。
里面还存在的小细节为：行为特征如何进行提取，如何计算用户之间的亲近度，如何对这个目标进行求解。

**本文方法使用的问题** 本文的作者具有能够接触真实用户匹配情况，是一种有监督的方法。
**启示** 
1. 如果能够将这个方法转化为无监督的方法也比较可行，但是行为相似度的提取依然是一个复杂的问题
2. 多目标的组合方法。最后目标函数中的每一维都是一个优化目标，多个优化目标同时进行。

***

###  De-anonymizing  Clustered  Social  Networks  by  Percolation Graph  Matching
> Carla-Fabiana Chiasserini, Michele Garetto, Emilio Leonardi:De-anonymizing Clustered Social Networks by Percolation Graph Matching. TKDD 12(2): 21:1-21:39 (2018)
> 2018-12-19 第二次整理（但还是没有看完，数学的东西太多）

中心思想：通过cluster描述网络的特征，提出wave-like propagation 定理，使得在只有很少的种子情况下也能识别很多用户。
**注** 这个算法有点难度，以后如果需要则需要进行整理。

***

### De-anonymizing scale-free social networks by percolation graph matching.
> Chiasserini, Carla-Fabiana, Michele Garetto and Emilio Leonardi. “De-anonymizing scale-free social networks by percolation graph matching.” _2015 IEEE Conference on Computer Communications (INFOCOM)_ (2015): 1571-1579.
> 2018-12-20 第二次整理

这篇文章是上面一篇的使用的都是同一个系列的算法，这个算法和COSNET算法中也有一定的关联，但是现在觉得论文太难，暂时没有仔细研读。

***

### User Identity Linkage by Latent User Space Modelling
> Mu, Xin, Feida Zhu, Ee-Peng Lim, Jing Xiao, Jianzong Wang and Zhi-Hua Zhou. “User Identity Linkage by Latent User Space Modelling.” _KDD_ (2016).
> 2018-12-21 第二次整理（需要再看一次，看懂其具体的方法）

**本文的主要思想** 引入隐平面空间的概念，在隐平面空间中匹配的用户对在空间中的距离是相近的，将这个假设转化为约束条件后等价于：
约束条件： 所有匹配对的距离大于所有非匹配对的距离
目标函数为：投射矩阵中的投射权重是最小的。这里可以理解为隐平面空间是一维的，所以投射问题为一个回归问题，那么借鉴机器学习中SVM理论，目标函数的权重为符合约束条件，但是权重需要尽可能的小，避免过拟合。
同时利用拉格朗日乘子将限制条件转移到目标函数中，使算法能够利用增量到达的匹配用户对来对模型进行不断的增量更新。

**注意** 其中的两个优化算法没有看懂，同时将其转化为增量的模型的过程也没有看懂，数学太差了。

采用的两个优化方法：
- constrained  concave-convex  procedure(CCCP)[20]
- a  gradient  descent  algorithm(accelerated proximal  gradient[22])

**启示** 将采用隐平面空间的算法和局部敏感哈希进行结合，局部敏感哈希中相似的用户应该投射到相同的桶中，但是哈希函数的选取是一个复杂的问题，如果能够采用隐平面空间的思想来代替这个映射过程的话或许有一个比较不错的效果。

###  REGAL: Representation Learning-based Graph Alignment.
> Heimann, Mark, Haoming Shen, Tara Safavi and Danai Koutra. “REGAL: Representation Learning-based Graph Alignment.” _CIKM_ (2018).
> 18-12-25 第一次阅读

**主要思想**：本文主要提出的是一种基于相似度的节点嵌入方法来进行用户的识别。所使用的嵌入方法不同于经典的节点嵌入方法，经典的方法中存在两个问题：1. 算法引入的差异导致当前的得到的向量表示不是可比较的；2.计算复杂度比较高
。

主要的流程：
1. 节点标识向量的抽取
- 结构特征：考虑K跳邻居的节点度数分布向量，一种对简单的方式为取向量的长度为最大的节点度数，每一维表示K跳邻居中度数为当前值的个数，其次为了解决度数的倾斜性，可以对度数进行取对数处理。
- 属性特征： 即简单的取F维特征，其中有一个重要的概念是节点的属性可能会存在缺失。
- 相似度的定义：对于结构特征向量直接使用其欧几里得距离作为其相似度，对于属性特征分为类别特征和实数类特征：类别特征采用匹配上的数目来定义相似度，是实数类使用欧几里得距离或者是余弦相似度来进行计算，最后将两种相似度进行加权求和。其实这里还有一个小技巧是使用采用负对数的方式将相似度转化到0~1之间。
2. 基于相似度的快速网络表示
    核心思想：针对节点相似矩阵进行分解，使其等于两个矩阵的乘积，最之后得到的左边的矩阵就是节点的向量表示（右边的矩阵可以直接丢弃，没有用处）。但是这样存在一个问题，S矩阵过于巨大，对其进行分解需要进行消耗大量的计算资源，于是想办法寻找一种相似度矩阵的近似表示，然后对其进行处理，显然可以使计算的复杂性降低。
    本文中方法：随机选取p个"landmark node"之后基于这p个节点来寻找相似矩阵的表示。采用**Nystrom method**算法得到一个S的近似矩阵的低阶表示，之后利用这个表达式进行化简以及矩阵**SVD分解算法**得到最终的的节点嵌入表示结果为：
    ![FgZjSA.png](https://s1.ax1x.com/2018/12/25/FgZjSA.png)
3. 基于网络表示的网络对齐
    为了避免计算所有两两节点之间的相似度，本论文首先采用k-d tree建立索引结构，之后进行节点的匹配时查找其最近邻居或邻居集合就是当前的候选匹配用户。
    k-d tree中保证每棵左子树的维上的值是小于当前节点维上的值，右子树上维上的值大于当前节点维上的值。


**启示** 其中的节点表示的方法可以使用，可以使用k-d tree 组织数据，降低匹配所需要使用的时间。


### Meta-path based multi-network collective link prediction.
> Zhang, Jiawei, Philip S. Yu and Zhi-Hua Zhou. “Meta-path based multi-network collective link prediction.” _KDD_ (2014).
> 2018-12-26 第一次整理

** 主要的思想 ** 提出元路径的方法俩进行特征的抽取。这里所谓的元路径启示个人感觉更像是类似知识图谱中的一条条知识，比如某个用户A-> 发布内容 -> 和某个用户B发布的信息比较相似（包含相同的单词）， 那么则存在一条从用户A到用户B的路径，通过类似的这种思想可以得到网内的元路径信息：朋友（粉丝）关系、存在共同关注、被同一个用户关注、内容相似度、时间相似度、地点相似度，以及跨网络的元路径信息：跨网络的元路径信息主要是通过调整锚定用户的位置得到四组跨网络的元路径信息。

如何利用元路径信息（如何将其转化为特征）？
特征的抽取方式

1. 同一个网络内部：（这里只包含五种元路径的处理方式（即可以得到一个五维的特征））：
    ![FgfatI.png](https://s1.ax1x.com/2018/12/26/FgfatI.png)
    上面这个公式的理解：首先第一二项用于限定元路径的开始和结尾，其次后面的部分为所有的元路径情况的总和
- 其中 I 类似于示性函数，即用来判断元素是否在集合中
- 其中p为formation probability, 具体的计算通过公式：
- ![FghpuD.png](https://s1.ax1x.com/2018/12/26/FghpuD.png)

2. 跨社交网络（总共具有四类元路径，可以得到一个四维特征）：采用共同信息（mutual information）作为每一维特征
    ![FghfVH.png](https://s1.ax1x.com/2018/12/26/FghfVH.png)


 具体原理在这次整理的过程中没有完整的看懂，但是知道其的简单思路为：回归到链路预测的本质，就是判断两个用户之间的用户是否存在联系，基于这个问题的本质，可以抽取网络中的已经存在的联系作为正例，其中不存在的作为负例（但是这里有一个需要注意的问题是，不存在不代表真的不存在，可能是缺失），在得到元路径信息后问题也已经转化为在知道的元路径信息下进行具体判断两个用户之间是否存在联系，即变成一个条件概率问题。

**启示** 这篇文章实际上是属于链路预测，使用多网的信息以及元路径来进行用户的链接预测，这不同用户识别问题，因为一个是单个网络内的，另外一个多个网络中，但是可以尝试以这种元路径的方式来解决用户识别问题。

### Novel Geometric Approach for Global Alignment of PPI Networks.
> Liu, Yangwei, Hu Ding, Danyang Chen and Jinhui Xu. “Novel Geometric Approach for Global Alignment of PPI Networks.” _AAAI_ (2017).
>  19-1-1 第一次阅读

主要思想：将识别的过程分为两个步骤，求解两个相似度，之后对这两个相似度进行加权求和得到最后的相似度。第一步为计算结构的相似度，在进行计算之前首先利用两个网络中节点的平均距离对其中一个网络进行放缩使两个网络具有相同的比例，之后首先利用网络嵌入（这里使用的是核函数）方法Structure Preserving Embedding得到网络的向量表示，之后引入Earth Mover's Distance （EMP），通过求解Earth Mover's Distance under Rigid Transformation得到一个两个网络中节点相似度的feasible max flow（就是两个网络中的节点相似度，和其他方法一样的都是通过最大化相似度来进行求解）。第二步引入蛋白质序列相似度使用Min-cost Max-flow的ICP方法来进行求解来进行求解。具体如下图所示。
![F5CBq0.md.png](https://s2.ax1x.com/2019/01/01/F5CBq0.md.png)

**启示** 与社交网络的关系与区别，网络嵌入时蛋白质网络可能有更多的训练数据集，其次蛋白质网络中拥有其特殊的蛋白质序列相似度。但是在社交网络中可以利用其它的方法来得到节点的表示得到节点的结构相似度的度量方式，其次可以利用其它的相似度来代替蛋白质序列相似度。

***

### An Iterative Global Structure-Assisted Labeled Network Aligner
>  Yasar, Abdurrahman and Ümit V. Çatalyürek. “An Iterative Global Structure-Assisted Labeled Network Aligner.” _KDD_ (2018).
>  19-1-7 第二次整理

**主要思想：**  本文的主要思想是提出一种基于结构的方法得到节点的坐标表示，之后将节点插入到QuadTree中，由于四叉树中某个层次的块中保存着相近的节点，以后的匹配只在每个桶中进行匹配，这样极大地加快了匹配的时间。

**节点的坐标表示方法：**
首先选出中心锚点（远离其他节点的锚点）、优势锚点（中心锚点中度数大于指定阈值的节点），之后将优势锚点中的节点根据最远的距离进行两两的组队，随机选一对后之后的所有对基于这点进行排序，最后将这些节点对对应到单位圆上。对应的方法为，第一对节点为（1,0）和 (0, -1)，之后的每对旋转角度180/节点对数放在圆上。将优势锚点安置完成后，以后没加入一个点时，计算当前点和在每对优势节点下的坐标构成一个多变型，多边形的中心就是当前节点的坐标表示。
![]([![FqFJjf.md.png](https://s2.ax1x.com/2019/01/07/FqFJjf.md.png)](https://imgchr.com/i/FqFJjf))

**四叉树（QuadTree）**
具体的理论百度，例如[博客](http://www.mamicode.com/info-detail-2313582.html)，其实也有点像k-d-tree。不同的是，四叉树主要实现了桶的功能，而k-d-tree能够实现范围查找能够查找出k个最近的邻居，个人理解k-d-tree也可以当做一个宽度固定的桶使用。
![](http://image.mamicode.com/info/201805/20180527110715265663.gif)
**桶内的相似度计算**
相似度的计算已经换汤不换药了，形式比较一般只是使用的特征比较多。
![FqFtu8.png](https://s2.ax1x.com/2019/01/07/FqFtu8.png)
![FqFNDS.md.png](https://s2.ax1x.com/2019/01/07/FqFNDS.md.png)

**关键信息或者启示** 启示这篇文章主要目的是通过桶的思想将节点划分至桶中，每个桶中的节点是比较相似的。为了实现这种划分，需要找到一种将节点的特征进行数字表示的形式，这篇文章中是通过节点和一部分锚点之间的关系来进行确定的（基于特殊的数据组合方式以及距离，感觉距离换成相似度也是能够行得通的），而regal那篇文章中是计算当前节点与其他节点之间的相似度，从某种角度而言两种算法存在一定的相似度，**为了表示自己需要通过别人进行表示**。那么从这个角度出发，如果能够对已经匹配的节点的信息能够有更多的使用的话应该会有新的方法生成。

**存在的问题** 首先距离的计算到底是什么方式？(后面理解了，这个距离就是跳数信息)其次这种方法如果考虑降维后那么又应该怎么表示？

****

### SiNA: A Scalable Iterative Network Aligner.
> Yasar, Abdurrahman, Bora Uçar and Ümit V. Çatalyürek. “SiNA: A Scalable Iterative Network Aligner.” _ASONAM_ (2018).
> 19-01-08 第一次阅读和整理

**主要思想** 这篇文章和上一篇文章是同一个人写的，但是这篇的主要的侧重为利用并行加快识别的速度。但是由于里面有很多东西都是从上一篇论文中来的，如果对于上一篇论文不是特别理解的话也是没有办法读懂这篇文章。

**识别的过程主要分为四步**
1. 单网内计算非锚点用户到锚点用户的最短距离（并行）
    可以采用牛皮的并行算法，但是没有必要，本文提出的方法为就是简单的将每个锚点的计算并行即可。
2. 选出重要的锚点，基于重要的锚点计算其余节点的坐标
    锚点的选择是前一篇论文的方法：首先选出中心锚点（远离其他锚点的节点），其次选出优势锚 点（中心锚点中大的部分），将一个网络中的所有优势锚点成对匹配（最远匹配法）并放置在单位圆上。每个节点和所有优势锚点利用三角函数计算得到坐标数组，这些坐标组成的多边形的质心就是节点的坐标。（具体参见上一篇论文）
3. 构建四叉树（并行）
    与上一篇论文不同的是，这篇论文对于每个网络构建一棵二叉树，分别记做QA和QB。为了能够实现并行，在叶子节点使用线程安全的容器装载节点，当节点需要分裂时通过锁机制保证只能有一个线程进行分裂操作，当分裂完成后移动数据可由多个线程一起协同完成。
4. 用户识别（网络对齐）（并行）
    首先定义相似度的计算公式。其次在桶和对应桶以及邻近桶中计算相似度寻找最相似度的匹配。其中对应桶的找法比较简单，就是包含该中心的桶。匹配时具有两种策略：每个桶和对应桶和其所有邻居的计算放在一个线程内（ComSimAll）;每个线程里面仅分配两个桶，即当前桶和对应桶或者对应桶的邻居桶，言外之意为匹配划分至多个线程中进行（ComSimPair）。第一种算法的问题在于桶中内容的多少不一致导致负载不均衡，第二种方法由于需要本地空间保存每对的匹配结果并且最后还有一个比较插入的时间开销。

**其他一些trick：**

1. 数据分布（排列）：
    提出两种数据排列方式（增加程序的局部性）
- BFS 分布：加快了相似度计算以及最短距离计算过程，但是四叉树的每个桶中内容不符合这种局部性
- HCB 分布：基于Hilbert 顺序对节点进行排序。增加桶内的局部性，加快相似度的计算。

2. 数据结构 ：将邻居的权重和类型等信息添加到节点的信息中

**想法或者说启示** 首先并行，可以在算法中使用。四叉树这种结构可以用，其次这种框架模型可以使用（得到节点的一种向量表示，在向量上进行计算识别，尽可能减少相似度计算的次数，最后尽可能将其中的耗时部分进行并行处理），**最后从数据结构层面进行优化还是第一次看见。**



***



### Global alignment of multiple protein interaction networks with application to functional orthology detection.

> Singh, Rohit, Jinbo Xu and Bonnie Berger. “Global alignment of multiple protein interaction networks with application to functional orthology detection.” *Proceedings of the National Academy of Sciences of the United States of America* 105 35 (2008): 12763-8.
>
> 2019-01-09 第二次整理



#### 1. 主要思想

本文的主要思想是利用pagerank的思想（当前节点的重要性由邻居进行决定），每对匹配的相似度性由邻居的相似性决定（利用了邻居这种传递性使得每对的相似度传递依赖于很多的点）从而考虑的是网络的全局信息。此外将其他类型的相似度加入到上面得到的结构相似度中，综合考虑两种相似性（但是这个地方好像 有列和需要为1的约束，因为这样才能和之前的矩阵对应上）。算法的名字称为IsoRank。

**主要流程**

1. 求解得到当前相似度向量
2. 基于相似度向量进行对齐，这里考虑多个网络



#### 2. 数学基础（妙啊）

1. 行和或者列和为1的随机矩阵的特征值为1，证明如下：

$$
A*\begin{vmatrix}1 \\ . \\ . \\ . \\ 1 \end{vmatrix}
= 
1*\begin{vmatrix}1 \\ . \\ . \\ . \\ 1 \end{vmatrix}
$$

在行和为1的条件下，上面的这个式子显而易见。

基于这个理论对于式 $1*\mathbf{a}=A\mathbf{a}$，如果希望求解a那么就等价于求解A矩阵的主特征向量

2. 主特征向量的求解方法: power method
   $$
   R(k+1) \leftarrow AR(k)/|AR(k)|
   $$
   其中$R(k)$代表第k次迭代的结果
   
#### 3.  相似度向量求解主要的过程

**第一步**：使用全局结构信息的算法建模

![](https://s2.ax1x.com/2019/01/10/FOlcSf.png)

- 其中R是一个向量，是由相似度矩阵按列展开后形成（展开的方向需要和A配对）



- 式子1的思想特别简单，每个匹配对的结构相似度信息由其邻居结构相似度决定，式子2 就是有权图情况下的表示，如果权重全部置为1就是式子1 的形式，即式子1是式子2的一种特殊形式。

- 式子3是式子1 的向量化表示
- A为一个克罗内克积维数的矩阵（mn*mn）

具体的例子如下图所示：

![](https://s2.ax1x.com/2019/01/10/FOlROg.png)

**第二步：** 融合结构信息和其他相似度信息

其中为了能够和A进行配对，需要对计算得到的相似度进行归一化处理。

![](https://s2.ax1x.com/2019/01/10/FO1tNn.png)

**第三步：**求解相似度向量R

等价于求解最大特征值1对应的特征向量，本文采用幂方法（Power method）进行求解
$$
R(k+1) \leftarrow AR(k)/|AR(k)|
$$
其中$R(k)$代表第k次迭代的结果

#### 3. 基于相似度向量的网络对齐（考虑多个网络的传递性）

**第1步：** 首先构建K部图，其中的每个K为网络的个数

**第2步：** 首先选出相似度最大的节点配对,相似度记为$S_m$

**第3步：** 选出相似度大于$\beta_1*S_m$

**第4步：** 利用前两步中得到节点作为中介，选出$R_{vw}\ge\beta_2R_{uv}​$



#### 4. 启示或者说想法

1. 利用这个方法得到的全局结构相似度替换REGAL方法中的相似度，然后利用REGAL的嵌入方法

2. 考虑这个方法的低维表示方法（之前好像已经有算法处理这个问题）

3. 可以考虑使用克罗内克尔积的形式得到上面的A，并且需要保证A为行和或者列和为1的矩阵。

***



### Message-Passing Algorithms for Sparse Network Alignment.

> Bayati, Mohsen, David F. Gleich, Amin Saberi and Ying Wang. “Message-Passing Algorithms for Sparse Network Alignment.” *TKDD* 7 (2013): 3:1-3:31.
>
> 2019-01-10 第二次整理，第二次依然还是没有看完，问题太过于复杂，公式太多



#### 1. 主要思想

这篇论文主要是将网络对齐问题进行泛化的数学定义，只有介绍了几种之前用过的优化方法，之后又提出两种基于置信传播的算法。这篇文章对于网络对齐问题的定义讲得特别的详细，问题具有很强的数学依据，在目标函数中考虑：节点的相似度和两个网络边重叠情况，提出目标函数后研究问题的约束条件。对目标函数就行变形处理或者对约束条件进行松弛处理可以得到不同的处理方法。

#### 2. 数学基础

**二次规划**

一个有n个变数与m个限制的二次规划问题可以用以下的形式描述。首先给定：

- 一个*n* 维的向量 **c**
- 一个*n* × *n* 维的对称矩阵Q
- 一个*m* × *n* 维的矩阵A
- 一个*m* 维的向量 **b**

则此二次规划问题的目标即是在限制条件为
$$
Ax\le b
$$


的条件下，找一个n 维的向量 $x$ ，使得
$$
f(x)=(1/2)x^TQx + c^Tx
$$
为最小。其中$x^T$是的$x$的转置。，注意发现式子中前面有个1/2

根据不同的参数特性，可以得到对问题不同的结论

- 如果Q是半正定矩阵，那么f(x)是一个[凸函数](https://zh.wikipedia.org/wiki/%E5%87%B8%E5%87%BD%E6%95%B0)。
- 如果Q是正定矩阵，那么全局最小值就是唯一的。
- 如果Q=0，二次规划问题就变成线性规划问题。
- 如果有至少一个向量x满足约束而且f(x)在可行域有下界，二次规划问题就有一个全局最小值x。

根据优化理论，一个点x成为全局最小值的必要条件是满足[Karush-Kuhn-Tucker条件](https://zh.wikipedia.org/wiki/Karush-Kuhn-Tucker%E6%A2%9D%E4%BB%B6)（KKT）。当f(x)是凸函数时，KKT条件也是充分条件。

当二次规划问题只有等式约束时，二次规划可以用线性方程求解。否则的话，常用的二次规划解法有：[内点法](https://zh.wikipedia.org/w/index.php?title=%E5%86%85%E7%82%B9%E6%B3%95&action=edit&redlink=1)(interior point)、active set和共轭梯度法等。凸集二次规划问题是[凸优化](https://zh.wikipedia.org/wiki/%E5%87%B8%E5%84%AA%E5%8C%96)问题的一个特例。

#### 3. 网络对齐问题的数学定义（二次整数规划形式）

**整体的思想**：利用克罗内克尔积得到候选的匹配对及每对匹配与其他匹配对之间是否存在互为邻居关系，通过一个指示向量从中选择匹配对使两个图之间的边的匹配度最大，之前可以得到的相似度可以转化到式子、在满足每个节点只能匹配到一个节点的限制条件下利用算法优化求解x使得两个网络的匹配度和相似度都最大。
$$
maximize\quad \alpha w^Tx + \beta/2x^TSx
$$

$$
subject \ to \quad Cx\le 1_{n+m}
$$

**参数的含义**

- $x$ 是指示当前匹配对是否成立的向量，同时也是最后的需要求解的向量

- $S$ 其实就是两个连接矩阵的克罗内克尔积，只是可能不是完整的，矩阵中值代表两个两对匹配节点的节点在各自的网络中是否是邻居，数学定义如下：
  $$
  S[ii',jj'] = \left\{ \begin{array}  
  0 1 \quad if\ (i, j)\in E_A \ and \ (i', j')\in E_B \\
  0 \quad otherwise
  \end{array} \right.
  $$

- $\quad Cx\le 1_{n+m}$ 等价于下面的式子,其实就是唯一匹配限制

  ![](https://s2.ax1x.com/2019/01/10/FOxZlT.png)

- 两个网络的重叠度（经过实际的测试，这个式子是成立的）
  $$
  (1/2)x^TSx = \sum_{ii' \ \ne\ jj'} x_{ii'}x_{jj'}
  $$















**解释：**

- 首先这个就是上面数学基础中形式，式子一模一样，所以接下来的主要问题是理解这个式子的具体含义
- $\alpha w^Tx$ 代表通过某种规则计算出来的相似度， $\beta/2x^TSx$ 代表两个网络的匹配程度（所谓的匹配程度代表两个匹配上的点对之间边的匹配程度，如下图例子中所示，如果$2\leftrightarrow2' \quad 4\leftrightarrow4'$ 两两匹配上，那么重叠的边就是$2\leftrightarrow4和 2'\leftrightarrow4'$）
- 限制条件中，C为一个$节点数 \times 候选匹配数（其实就是二部匹配图中边数）$，具体看下面例子就懂。这个限制的条件代表每个节点只能有一种匹配，即实现一对一的限制

**例子：**

![](https://s2.ax1x.com/2019/01/10/FOxa0H.png)

#### 4. 网络对齐的应用

模式识别、实体识别、生物网络中的共同路径等等

#### 5. 之前的算法

**5.1 IsoRank Algorithm**

主要的思想是在解决问题时直接绕过了约束条件限制，直接利用了行和为1的随机矩阵的性质进行求解主特征向量即可。具体见对应的论文，那个也很清晰。

原始的迭代公式：![](https://s2.ax1x.com/2019/01/10/FOzg8x.png)

克罗内克尔积：![](https://s2.ax1x.com/2019/01/10/FOzzZQ.png)

克罗克内尔积具有的性质1：![](https://s2.ax1x.com/2019/01/10/FXSCin.png)

向量化操作：![](https://s2.ax1x.com/2019/01/10/FXSAMT.png)

经过变形后的迭代公式：![](https://s2.ax1x.com/2019/01/10/FXSmdJ.png)
克罗克内尔积具有的性质2：$Q\bigotimes P = diag[S1_{|E_l|}](B\bigotimes A)​$
**理解：**

这其实是一个不断转化的过程（但是感觉没有必要，看原来的论文就很好了）。

针对每次迭代的$z​$ 采用bipartite max-weight matching进行匹配得到匹配的结果，从中选出最好的一次作为结果输出。论文的最后选取的是page rank方法（其实也不能说是pagerank方法，就是这种思想）。

**5.2 Linear Program Formulations**

怎么说呢，这其实就是一种优化算法，对于这个层面提不出有用的算法来对其进行优化，所有能用就行。（或者说将问题转化为这种形式后，利用这种形式优化）

这种想法来源于：mixed integer translations或者quadratic assignment。 在这个方法中引入另外的一个变量y，将之前的目标函数变换为另外的一种形式。观察下面的式子其实就是将匹配部分使用另外的一种形式进行表达，其中能够能够将目标表达式进行化简。

![](https://s2.ax1x.com/2019/01/11/FXauWQ.png)

写成矩阵形式后：![](https://s2.ax1x.com/2019/01/11/FXdB9g.png)

**5.3 Klau's Iterative Matching Relaxation**

在这种方式中引入了Lagrange multipliers，将5.2中的的对称限制转移到目标函数中，

![](https://s2.ax1x.com/2019/01/11/FXwGPU.png)

将上面的目标函数展开后可以得到下面的式子，以及结合分析可以将式子进行一步化简。

![](https://s2.ax1x.com/2019/01/11/FX0Zo6.png)

对w进行重新的改写后，可以将目标表达式进行化简。

![](https://s2.ax1x.com/2019/01/11/FX00yj.png)

另外论文中还讲了一个tightened LPs。具体的过程就省略了，如果需要就看原文。

#### 6. 本文提出的算法：

借鉴信息传播（置信传播）算法求解目标函数。在提出一个基本方法后又提出一个新的改进算法，但是这两个方法都没有看懂，手动尴尬脸。

#### 7. 启示或者想法

首先网络对齐问题的数学定义形式是一个比较好的理论基础，可以利用其他的信息往这个方面上靠。然后就可以得到一个问题的求解方法。但难点也在于对于问题及已知信息的建模过程。

其次，这篇论文其实是克罗克内尔积的一个使用。邻接矩阵的克罗克内尔积需要配合一个匹配指示函数或者说矩阵，此外现在克罗克内积使用的结构上的信息，可以尝试将将其他的信息整合到这个矩阵中。或者说使用这个连接信息传递得到更多的信息。



***



###  Multimodal Network Alignment.

> Nassar, Huda and David F. Gleich. “Multimodal Network Alignment.” *SDM* (2017).
>
> 2019-01-20 第二次整理
>
> 本文主要针对的是生物网络
>
> spring 上的文章，根据这类文章总结出来，spring期刊上面的论文不要看了，太长也太难

#### 中心思想

根据IsoRank方法带来的启示，利用网络的多模式构建多模式（不同类型的边）的邻接矩阵，然后在这个邻接矩阵上利用PageRank以及矩阵分解的方法对其进行求解得到最终的结果。

####  本文具体的方法

**IsoRank**

目标矩阵，其中$Y$中代表的就是不同网络中两个节点的相似度
$$
Y = \alpha PYQ^T + (1-\alpha)S
$$
其中S为初始的相似度矩阵，用户可以没有这个相似度矩阵，如果没有则默认填入$|V_A|^{-1}|V_B|^-{1}$

当S中没有具体的相似度信息时，$rank(S)=1$，而对于秩为1的矩阵，具有$S=uv^T$,在使用PageRank算法后，经过t次迭代的结果为：
$$
Y^{(t)} = (1-\alpha) \sum_{k=0}^{t-1} \alpha^kP^kuv^T(Q^T)^k + \alpha^tP^tuv^T(Q^T)^k
$$
注意上面的式子的计算效率一般比较好，一般t位于5~25之间，$\alpha=0.9$

**Our decomposition**

多模式下的S矩阵：

![](https://s2.ax1x.com/2019/01/20/kPAk1x.png)

其中，$\gamma=m^{-1}|V_A|^{-1}|V_B|^{-1}$, S是一个秩为m的矩阵

如果使用M和N分别表示，多模式下的邻接矩阵，那么目标矩阵变为：
$$
Y_{MN} = \alpha P_MY_{MN}Q_{MN}Q_N^T + (a-\alpha)S
$$
依然继续利用PageRank进行迭代优化可以得到如图所示的具体算法：

![](https://s2.ax1x.com/2019/01/20/kPACN9.png)

定理：如果$Y=UV^T$ 是一个秩为k的矩阵Y的分解，如果$X_i$是拥有一阶秩的矩阵$u_iv_i^T$的最大权重匹配，并且$f_i=X_i\bullet(u_iv_i^T)$是上述匹配的权重，如果$f^*$是$f_i $中最大的值，那么$f^* $ 是$Y$ 的一个$1/k$的近似。

冲突的解决：

由于是多模式，在不同的模式下相同的点可能会匹配到不同的点，对于这种冲突具有两种处理方法：

方法1：采用贪婪匹配算法

方法2：将其建模成为二部图网络，在这个图中寻找最大的二部匹配图

#### 启示或者想法

多模式信息的使用不太常见，可以考虑使用，但是涉及到具体的数据集。

其次对于PageRank算法的使用好像需要好好的了解，也许能够再重新利用一次。

最后如果$Y_i=u_iv_i^T$ ,那么Y所代表的的匹配就是两个向量$u_i和v_i$分别按照从大到小排列后的一一对应。



***



### Low Rank Spectral Network Alignment.

> Nassar, Huda, Nate Veldt, Shahin Mohammadi, Ananth Grama and David F. Gleich. “Low Rank Spectral Network Alignment.” *WWW* (2018).
>
> 2019-01-13 第二次整理



**前言**： 其实和大多数的spectral alignment方法一样，都是希望能够从所有点的配对情况（配对的情况一般存在一个矩阵中，并且矩阵中的值代表的是当前匹配对的相似度信息）中找到一个选择机制（向量或者是矩阵）来从中选出最为合适的配对。如何进行选择呢？选择时通过一对一的限制条件可以知道特殊位置是不能同时被选中的。那么这类算法中的研究点在于：

- 如何将其中所用到的矩阵进行降维，即用低阶矩阵来表达原始的目标。
- 其次，两个节点之间的匹配相似度如何得到？可以通过迭代的方式得到，也可以通过基于定义的结构相似度或属性相似度得到，此外除去相似度的计算，还有各种情况的组合，即利用一些当前没有被人们使用过的信息。
- 选择机制（向量或者说维度怎么求解），即优化算法的使用也是一个研究的方向，找到更加高效的方法来进行识别。

**思想：** 分析前人的目标函数，考虑到之前的目标函数中仅考虑到了网络的匹配信息，没有考虑利用不匹配信息，所以文中提出一个模型能够同时考虑边的匹配、不匹配、匹配冲突（这里说的是两对配对点之间的联系的对应情况）。在提出这个模型后，由于其中的匹配矩阵维度很大，于是将矩阵进行分解或者说得到矩阵的低阶表示方式，然后在低阶的矩阵上进行识别。最后在得到的低阶矩阵的表达形式中进行最后的网络对齐工作。

#### 主要流程

1. **匹配与不匹配信息**
     ![](https://s2.ax1x.com/2019/01/13/Fvh9US.png)
     其中对于冲突情况时，代表的是两类冲突，一边右边另外一边没有边。
2. **传统的优化目标**

![](https://s2.ax1x.com/2019/01/13/FvOK3V.png)

其中的M为所有的匹配情况形式成的$mn \times mn$矩阵，矩阵中的值代表的是匹配的相似度。$y$是一个mn维的向量（由一个$m \times n$ 的矩阵压扁形成，其中的每个位置代表两个节点是否匹配），其中的每个值代表当前匹配对是否是成立的。

缺点：是由M的定义所导致的，其中仅包含匹配部分的信息没有包含不匹配、或者匹配冲突等信息。

3.  **本文提出的目标**(其实是EigenAlign 算法中提出来，本文的主要目标是寻找其的低阶矩阵表示)

在$P(i_B, i_B^{'}) = 1 \ and \ P(j_B, j_B^{'}) = 1$的条件下(这里的P为y的矩阵形式)：

![](https://s2.ax1x.com/2019/01/13/FvOSht.png)

上面的式子表示的带无匹配以及匹配冲突的渗透图的矩阵表示形式为：

![](https://s2.ax1x.com/2019/01/13/FvOABQ.png)

所以目标函数可以表示为：

![](https://s2.ax1x.com/2019/01/13/FvhnET.png)

利用行和为1的随机矩阵的主特征值为0，可以得到下面的等价优化目标：

![](https://s2.ax1x.com/2019/01/13/FvOwjO.png)


4. **Low Rank Factors of EigenAlign**（需要严格的数学推导，但是具体没有搞太懂）

经过一系列严格的数学公式的推倒可以得到X的四因子形式、三因子形式以及两因子形式，对于具体的推导过程就不在详细地叙述，如果需要就看原文，其中用到的一个重要思想依然还是SVD分解，最后基于提出的分解算法得到最后的算法。

![](https://s2.ax1x.com/2019/01/13/FvXC5R.png)

基于上面的算法我们可以得到两因子形式的一个近似。

5. **基于低阶矩阵的网络对齐**

由于低阶矩阵是采用迭代的算法计算得到，在每次的迭代中能够产生一个u和v向量，由这两个向量能够计算得到$Y$,所以先考虑一个向量u和v的情况下如何进行对齐。想法特别简单，对于$Y$的中放入结果全是正（分）的，那么对齐进行排序，最大（小）的值就是匹配的。如果是两种混在一起的，可以先将两类进行分开，分别计算，再将其结果进行汇总，这种方法是通过证明，是可行的。



####  想法或者启示  

可以加入其它的相似度。



***



### A co-training method for identifying the same person across social networks.

> Fang, Zheng, Yanan Cao, Yanbing Liu, Jianlong Tan, Li Guo and Yanmin Shang. “A co-training method for identifying the same person across social networks.” *2017 IEEE Global Conference on Signal and Information Processing (GlobalSIP)* (2017): 1412-1416.
>
> 2019-01-



***



### Community-Based Network Alignment for Large Attributed Network.

> Chen, Zheng, Xinli Yu, Bo Song, Jianliang Gao, Xiaohua Hu and Wei-Shih Yang. “Community-Based Network Alignment for Large Attributed Network.” *CIKM* (2017).
>
> 2019-01-



***



### Active Network Alignment: A Matching-Based Approach.

> Malmi, Eric, Aristides Gionis and Evimaria Terzi. “Active Network Alignment: A Matching-Based Approach.” *CIKM* (2017).



***



### FASTEN: Fast Sylvester Equation Solver for Graph Mining.

> Du, Boxin and Hanghang Tong. “FASTEN: Fast Sylvester Equation Solver for Graph Mining.” *KDD* (2018).
>
> 2019-01-



***



### HashAlign: Hash-Based Alignment of Multiple Graphs.

> Heimann, Mark, Wei Ting C Lee, Shengjie Pan, Kuan-Yu Chen and Danai Koutra. “HashAlign: Hash-Based Alignment of Multiple Graphs.” *PAKDD* (2018).
>
> 2019-01-



***



### iNEAT: Incomplete Network Alignment.

>Zhang, Si, Hanghang Tong, Jie Tang, Jiejun Xu and Wei Fan. “iNEAT: Incomplete Network Alignment.” *2017 IEEE International Conference on Data Mining (ICDM)* (2017): 1189-1194.
>
>2019-01-



***



### Matching user accounts based on user generated content across social networks.

> Li, Yongjun, Zhen Zhang, You Peng, Hongzhi Yin and Quanqing Xu. “Matching user accounts based on user generated content across social networks.” *Future Generation Comp. Syst.* 83 (2018): 104-115.
>
> 2019-01-



***



### Multiple Anonymized Social Networks Alignment.

> Zhang, Jiawei and Philip S. Yu. “Multiple Anonymized Social Networks Alignment.” *2015 IEEE International Conference on Data Mining* (2015): 599-608.
>
> 2019-01-22 第一次整理

#### 主要思想或核心

本文整体的思想比较简单，不外乎满足三点限制：最大化边的重叠度，每个节点最多匹配到一个节点，以及在多网络的情况下需要保持传递性。根据上面的三点限制建立优化目标，寻找转移矩阵和匹配矩阵使上面的优化目标符合条件。

#### 主要方法

1. 构建转移矩阵的优化目标

![](https://s2.ax1x.com/2019/01/22/kFJTpt.png)

其中：S为邻接矩阵，T为转移矩阵，其中$(T^{(i, j)})^TS^{(i)}T^{(i, j)}$代表将$S^{(i)}$投射到$S^{(j)}$后的样子，即使得两个网络具有可比性。这个具体的数学基础不知道，但是经过实际的测试后确实是这个结果。后面个的限制条件，即简单的一对一限制。

2. 引入传递性惩罚因子

传递性惩罚因子：想法特别简单，就是从不同路径传播的结果应该是相近的，下面以三个网络的作为例子，

![](https://s2.ax1x.com/2019/01/22/kFN1FH.png)

泛化到多个网络的情况下，其实就是对于所有三个网络组合的结果

![](https://s2.ax1x.com/2019/01/22/kFN4k4.png)

加入了惩罚因子后目标函数变为：

![](https://s2.ax1x.com/2019/01/22/kFUp9A.png)



上面的这个式子中的限制让这个式子特别的难解，于是对上面的结果进行松弛处理

3. 松弛目标限制

就是T中只能进行0或1取值松弛为0到1之间的任意数，于是限制条件变为：

![](https://s2.ax1x.com/2019/01/22/kFUhKP.png)

4. 使用梯度下降算法迭代计算

![](https://s2.ax1x.com/2019/01/22/kFaTL6.png)

5. 传递匹配限制

   对于三个网络时不匹配限制为：

![](https://s2.ax1x.com/2019/01/22/kFdzh4.png)

 拓展到多网络：

![](https://s2.ax1x.com/2019/01/22/kFwdvn.png)

6. 最后的优化目标：

   ![](https://s2.ax1x.com/2019/01/22/kFw5b6.png)

   其中的多网络的传递性不是凸的，将这个限制放到目标函数中。最后这个优化问题可以使用，Scipy.Optimization和GLPK进行求解。





***



###  Social Identity Link Across Incomplete Social Information Sources Using Anchor Link Expansion.

>Zhang, Yuxiang, Lulu Wang, Xiaoli Li and Chunjing Xiao. “Social Identity Link Across Incomplete Social Information Sources Using Anchor Link Expansion.” *PAKDD* (2016).
>
>2019-01-21 第二次整理

#### 主要思想

提出一种基于局部拓展的识别方法进行识别，使得算法的性能得到很大的改善，这种策略的优势在于不用在于计算所有的匹配对，每次计算只用计算候选的top p。此外文章中分析以前很多文章中使用的特征容易由于隐私问题而不能得到，并且这些方法中非常依赖于这些属性，为了避免这个问题，本文提出的算法中利用的都是各个网络中公开的属性，例如昵称、性别、年龄、大学名称、大学入学年份、住址、公开的社交信息，在利用公开的属性使用有监督的分类模型进行相似度的计算。

#### 算法的主要流程

前提假设：在一个网络中是朋友的用户在另外的网络中是朋友的概率非常大，基于这种假设能每次识别时能够从已经识别的匹配对开始进行迭代的匹配。

算法的思想非常简单：

![](https://s2.ax1x.com/2019/01/21/kP2MIx.png)

1. **抽取策略**

   采用广度搜索优先的方式从匹配的用户对开始进行搜索，基于距离已经匹配节点的边数定义距离，于是通过限制最大的边数（换种说法的话就是跳数）能够得到一个搜索空间。

2. **特征抽取：**

- 昵称相似度

  比较的类别：公共子串、公共字符、将昵称转为拼音（避免例如繁体、简体之间的区别）

  相似度的计算公式(其中涉及到太多符号的定义，在这个地方不在详细的列出推导)：

  ![](https://s2.ax1x.com/2019/01/21/kP2qm9.png) 

- 位置相似度

  主要的思想：不同网络中可能有多种不同类型的地址，对于这些地址的直接一对一匹配一般是错误的，但是用户的朋友和其的位置序列具有相似性，基于这点发现通过比较邻居节点位置相似度来度量位置相似度。

  ![](https://s2.ax1x.com/2019/01/21/kPRplD.png)

  如上图所示，首先定义三个概念：源网络中朋友的位置集合$CL$、目标网络中朋友的位置集合$HO$、目标网络中节点的家乡$l_h$（hometown）,位置的匹配情况分为四类：

  1. 不存在$l_h​$,并且$CL​$和$HO​$没有交集，那么相似度为0
  2. 不存在$l_h​$,但是$CL​$和$HO​$具有交集，相似度计算公式为：

  ![](https://s2.ax1x.com/2019/01/21/kPRtpT.png)

  3. 存在$l_h$,$CL$和$HO$具有交集，并且$l_h$ 不在$HO$中，相似度计算公式为：

     ![](https://s2.ax1x.com/2019/01/21/kPRIAI.png)

  4. 存在$l_h$,$CL$和$HO$具有交集，并且$l_h$ 在$HO$中，相似度计算公式和3中的很像，没有找到论文中所说的公式5，根据个人的理解，就是在2中的相似度中在多加一个$l_h$的概率，或者说把3中的$\alpha$换成$P(Hi(I_i^s)=l_k)$

- 社交相似度

  特别简单粗暴，就是基于共同用户进行定义

![](https://s2.ax1x.com/2019/01/21/kPWn4x.png)

3.**相似度计算**

使用分类模型进行计算，例如：MLP、LR、NB、SVM

#### 启示或者说想法

就是其中的各种相似度的计算公式可以计算，其次可以在自己的方法中加入这些相似度。

***



## Spectral Alignment of Network(Graphs)

> Feizi, Soheil, Gerald Quon, Mariana Recamonde Mendoza, Muriel Médard, Manolis Kellis and Ali Jadbabaie. “Spectral Alignment of Networks.” *CoRR* abs/1602.04181 (2015): n. pag.
>
> 2019-01-15 第一次整理
>
> 这篇论文有代码地址为：https://github.com/SoheilFeizi/spectral-graph-alignment

#### 主要思想：

这篇论文主要不仅考虑了边的重叠度同时还考虑了边的不重合以及匹配的两对点之间不存在联系，为什么需要考虑边不匹配或者说匹配的两个点之间不存在联系的情况呢？具体见下面的这个例子,如果在不考虑边的没有匹配上的情况时，$X_0$ 显然是需要匹配到$X_1$ 但是其实匹配到$X_2$更为合适。综合考虑边的各种匹配情况后将这些信息相似度矩阵（匹配矩阵或者说渗透图）中，之后将目标建模成为二次分配问题（quadratic assignment problem）进行识别。在得到优化目标后提出两种优化的方法来求解问题：基于主特征向量的方式和低阶的对齐算法。

![](https://s2.ax1x.com/2019/01/15/FzDesS.png)

注：这篇论文中提到的数学概念比较多，已经整理成为专门的一篇文章

> 常用的数学基础

#### 针对QAP（二次分配）的前人算法

-  Exact search methods

  主要方法有，分支限界、割平面法。

  缺点是：费时间

- Linearizations

  主要的方式是使用mixed integer program(MILP).

- Semidefinite/convex relaxations（半正定和凸优化）

  Semidefinite programming（SDP）算法。以及计算机视觉领域的方法。

- 其他的方法

  贝叶斯网络、Message passing、以及其他的启发式算法
  

#### 本文算法

**图同构问题：** 如果存在一个置换矩阵P存在使得$G_1 = PG_2P^T$成立，则称两个网络是同构的。

首先定义两对匹配点之间的关系：

![](https://s2.ax1x.com/2019/01/15/FzfajA.png)

基于上面的定义，现在可以得到边的匹配矩阵A。

此时的求解目标为（其实感觉这个是混合整数规划的的目标）：

![](https://s2.ax1x.com/2019/01/15/FzfoNT.png)

- **EigenAlign Algorithm算法**

1. 第一步求解A矩阵的主特征向量， 在求解主特征向量时（暂时不考虑二部匹配的限制，因为在下一步处理时考虑到了这个问题）
2. 利用特征向量的性质$Ax = \lambda x$ 问题的求解转化为最大权重的二分匹配优化：

![](https://s2.ax1x.com/2019/01/15/Fzh8rn.png)

将上述问题近似化后（将约束进行放缩）：
$$
\mathop{max}\limits_{y}\quad y^TAy, \\
||y||_2 \le 1
$$
对于第一步求解的主特征向量就是上面这个优化目标的的一个近似解。

后面还讲了一些噪声的生成办法。


- **LowRankAlign Algorithm**

前注：里面涉及到一些没有看懂的知识点。仅列出主要的思想：

1. 利用正交矩阵来松弛优化目标
2. 在特征向量方向投影

$$
max\quad Tr(G_1XG_2X^T),\\
X \in \tau.
$$

其中$\tau​$ 是一个正交矩阵

**定理3** 当U和和V分别为网络的两个特征向量矩阵时,存在
$$
X_0 = VU^T = \sum_{i=1}^n v_i u_i^t
$$
是上面优化目标的一个解。

其他部分看不懂。。。



### 想法或启示

在线性代数的范围内还大有可为，但是需要线性代数理论知识作为支持。



***



### Fifty years of graph matching, network alignment and network comparison.

> Emmert-Streib, Frank, Matthias Dehmer and Yongtang Shi. “Fifty years of graph matching, network alignment and network comparison.” *Inf. Sci.* 346-347 (2016): 180-197.
>
> 2019-01-19 第一次阅读整理

#### 前提

论文看得比较浅，没有看得特别认真，当前方法更主要的是针对生物网络的匹配、对齐以及网络比较问题。并且和当前看到的算法存在一些脱节，感觉不是一类文章。

#### 本文的主要思想

本文根据数据类型的不同将识别方法分为两个类别，其中第一类中网络为random graph（随机图），第二类网络的图为deterministic graph（确定图）。

![](https://s2.ax1x.com/2019/01/19/kCikRK.png)

### Distribution Distance Minimization for Unsupervised User Identity Linkage

> Li, Chaozhuo, Senzhang Wang, Philip S. Yu, Lei Zheng, Xiaoming Zhang, Zhoujun Li and Yanbo Liang. “Distribution Distance Minimization for Unsupervised User Identity Linkage.” *CIKM* (2018).

#### 1. 摘要

将用户识别问题转化为找一个投射函数来最小化两个网络的最小推土机距离。

#### 2.数学基础

[从Wasserstein距离、对偶理论到WGAN - Paper weekly - CSDN博客](<https://blog.csdn.net/c9yv2cf9i06k2a9e/article/details/86762056>)

[Wasserstein距离在生成模型中的应用 - Paper weekly - CSDN博客](<https://blog.csdn.net/c9Yv2cf9I06K2A9E/article/details/80016095>)

##### 2.1 EMD(Earth Mover's Distance)  ---- 推土机距离

一个具体的例子如下所示，其核心的思想就是**求距离的期望**

![img](https://vincentherrmann.github.io/images/wasserstein/P_r.png)

![img](https://vincentherrmann.github.io/images/wasserstein/P_theta.png)

![](https://s2.ax1x.com/2019/04/01/AyPpee.png)

##### 2.2 Wasserstein 距离

[![AyEKGd.md.png](https://s2.ax1x.com/2019/04/01/AyEKGd.md.png)](https://imgchr.com/i/AyEKGd)

##### 2.3 **Kantorovich-Rubinstein Duality**

具体的推倒过程见上面的提到的博客

[![AyDYv9.md.png](https://s2.ax1x.com/2019/04/02/AyDYv9.md.png)](https://imgchr.com/i/AyDYv9)

根据对偶性质，推土机距离又可以转化为：

[![AyDaHx.md.png](https://s2.ax1x.com/2019/04/02/AyDaHx.md.png)](https://imgchr.com/i/AyDaHx)

##### 2.4 

##### 2.5 狄拉克函数（Dirac delta function）

狄拉克函数是一个广义函数，该函数除了在零以外的点的取值都等于零，而在整个定义域上的积分等于1

![AyiiBF.png](https://s2.ax1x.com/2019/04/01/AyiiBF.png)

##### 2.6 生成对抗网络

生成对抗网络（GAN）提供了一种不需要大量标注训练数据就能学习深度表征的方式。它们通过反向传播算法分别更新两个网络以执行竞争性学习而达到训练目的。

生成器和判别器通常由包含卷积和（或）全连接层的多层网络构成。生成器和判别器必须是可微的，但并不必要是直接可逆的（理论分析上必须可逆）。

原始 GAN 的判别网络 D 可以看成是**将图像数据映射到**（该图像是来自真实数据分布，而不是生成器分布）**判别概率的函数 D : D(x) → (0, 1)**。对于一个固定的生成器 G，判别器 D 可能被训练用于分辨图像是来自训练数据（真，概率接近 1）还是来自生成器（假，概率接近 0）。若判别器已经是最好的，它将变得无法被欺骗，而这时生成器 G 需要继续训练以降低判别器的准确率。如果生成器分布足以完美匹配真实数据分布，那么判别器将会被最大地迷惑而对所有输入给出 0.5 的概率值。**简言之，固定生成器的情况下，训练判别器判别数据来自于原始的数据或由生成器生成；固定判别器的情况下，使生成器生成的数据被判别器判别出来的概率最小，如果循环迭代直到结果最优或者达到迭代次数**

![img](http://5b0988e595225.cdn.sohucs.com/images/20171022/b68771ff59d943c8aa9eb6dc88a1433a.jpeg)

 这张图分别展示了 GAN 中的判别器 D 和生成器 G 的训练流程。通常利用神经网络实现，但实际上它们可以用任意形式的（将数据从一个空间映射到另一个的）可微系统实现。

[深度学习优化算法解析(Momentum, RMSProp, Adam) - willduan的博客 - CSDN博客](<https://blog.csdn.net/willduan1/article/details/78070086>)

##### 2.7  Orthogonal Procrustes problem

![R=\arg \min _{\Omega }\|\Omega A-B\|_{F}\quad \mathrm {subject\ to} \quad \Omega ^{T}\Omega =I,](https://wikimedia.org/api/rest_v1/media/math/render/svg/de040825f55ae2f5ada7ceb6bd87cd0335e02f79)

这个问题等价于：

[![AyWjaj.md.png](https://s2.ax1x.com/2019/04/02/AyWjaj.md.png)](https://imgchr.com/i/AyWjaj)