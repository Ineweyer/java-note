## 腾讯一面

### 1. 说说nodejs

#### 1.1 特点：

- 简单强大，轻量可扩展．简单体现在node使用的是javascript,json来进行编码，人人都会；
- 强大体现在非阻塞IO,可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；
- 轻量体现在node本身既是代码，又是服务器，前后端使用统一语言;
- 可扩展体现在可以轻松应对多实例，多服务器架构，同时有海量的第三方应用组件。

#### 1.2 核心模块

- EventEmitter
- Stream
- FS
- Net
- 全局对象

#### 1.3 什么是事件循环

Node采用的是单线程的处理机制（所有的I/O请求都采用非阻塞的工作方式），至少从Node.js开发者的角度是这样的。 而在底层，Node.js借助**libuv**来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。下图表示了Node和libuv的关系。



![img](https:////upload-images.jianshu.io/upload_images/675733-c76f15bc26c1a062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/358/format/webp)



Libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个事件循环， 以异步的方式将任务的执行结果返回给V8引擎。可以简单用下面这张图来表示。



![img](https:////upload-images.jianshu.io/upload_images/675733-f7b7aa3c83231f54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp)



（图片来源于网络）

每一个I/O都需要一个回调函数——一旦执行完便推到事件循环上用于执行。 如果你需要更多详细的解释，可以参考**这个视频**。 你也可以参考**这篇文章**。

**解释：**这用于检查Node.js的底层知识，例如什么是libuv，它的作用是什么。

#### 1.4 使用NPM有哪些好处

通过NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。 对于Node应用开发而言，你可以通过`package.json`文件来管理项目信息，配置脚本， 以及指明项目依赖的具体版本。

#### 1.5 什么是Stub？举个使用场景(用户测试)

Stub是用于模拟一个**组件**或模块的**函数或程序**。在测试用例中， 简单的说，你可以用Stub去模拟一个方法，从而避免调用真实的方法， 使用Stub你还可以返回虚构的结果。你可以配合断言使用Stub。

#### 1.6 常用js类定义的方法有哪些？**

参考答案：主要有**构造函数原型**和**对象创建**两种方法。原型法是通用老方法，对象创建是ES5推荐使用的方法.目前来看，原型法更普遍.

代码演示
1) 构造函数方法定义类

```javascript
    function Person(){
        this.name = 'michaelqin';
    }
    Person.prototype.sayName = function(){
        alert(this.name);
    }

    var person = new Person();
    person.sayName();
```

2) 对象创建方法定义类

```javascript
    var Person = {
        name: 'michaelqin',
        sayName: function(){ alert(this.name); }
    };

    var person = Object.create(Person);
    person.sayName();
```

####  1.7  js类继承的方法有哪些， js类多重继承的实现方法是怎么样的?

**参考答案**：**原型链法**，**属性复制法**和**构造器应用法**. 另外，由于每个对象可以是一个类，这些方法也可以用于对象类的继承．

**参考答案**：就是类继承里边的**属性复制法**来实现．因为当所有父类的prototype属性被复制后，子类自然拥有类似行为和属性．

1) 原型链法

```javascript
    function Animal() {
        this.name = 'animal';
    }
    Animal.prototype.sayName = {
        alert(this.name);
    };

    function Person() {}
    Person.prototype = Animal.prototype; // 人继承自动物
    Person.prototype.constructor = 'Person'; // 更新构造函数为人
```

2) 属性自制法

```javascript
    function Animal() {
        this.name = 'animal';
    }
    Animal.prototype.sayName = {
        alert(this.name);
    };

    function Person() {}

    for(prop in Animal.prototype) {
        Person.prototype[prop] = Animal.prototype[prop];
    } // 复制动物的所有属性到人量边
    Person.prototype.constructor = 'Person'; // 更新构造函数为人
```

3) 构造器应用法

```javascript
    function Animal() {
        this.name = 'animal';
    }
    Animal.prototype.sayName = {
        alert(this.name);
    };

    function Person() {
        Animal.call(this); // apply, call, bind方法都可以．细微区别，后面会提到．
    }
```

#### 1.8 js里的作用域是什么样子的？

**参考答案**：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫**函数作用域**，就是一个**变量在全函数里有效(函数里面定义的变量在函数的任意位置有效)**．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined.

#### 1.9 js里面this指的是什么？

**参考答案：**this指的是**对象本身（并且是运行的对象，这个问题在事件中比较常见，又是需要使用其他变量将this保存下来）**，而不是构造函数

```javascript
    function Person() {
    }
    Person.prototype.sayName() { alert(this.name); }

    var person1 = new Person();
    person1.name = 'michaelqin';
    person1.sayName(); // michaelqin
```

#### 1.10 **apply, call和bind有什么区别?**

**参考答案**：三者都可以**把一个函数应用到其他对象上**，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表，



### 参考资料

- [10个常见的Node.js面试题](https://www.jianshu.com/p/3416a0bf309c)
- [node.js面试题大全－侧重后端应用与对Node核心的理解](https://www.cnblogs.com/meteorcn/p/node_mianshiti_interview_question.html)