# 招生办项目

前面都是满满的知识点，虽然不一定有用 (~_~)

关于项目的假想问题是第4和第5部分

## 1. 权限控制

### 1.1 基本术语

- 用户（Subject），发起操作的主体
- 对象（Object，也可以称为Resource（资源）），指操作所针对的客体对象（如订单数据，或图片数据）
- 权限控制表（ACL: Access Control List，另外一种表现形式，ACM：Access Control Matrix），用来描述权限规则或者用户和权限之间关系的数据表（矩阵）
- 权限（Permission，也可以称为许可），用来指代对某种对象的某种操作
- 权限标识，权限的代号
- 角色（Role），权限的集合

### 1.2 常见设计模式

#### 1.2.1 自主访问控制（DAC: Discretionary Access Control）

##### 1.2.1.1 基本流程：

系统会**识别用户**，然后根据被操作对象（Subject）的**权限控制列表（ACL: Access Control List）或者权限控制矩阵（ACM: Access Control Matrix）**的信息来决定用户的是否能对其进行哪些操作，例如读取或修改。

原始的DAC中，主体对它所属的对象和运行的程序拥有全部的控制权，就是如果可以访问那么则拥有其所有的权限。改进的DAC实现提供了一个基于“need-to-know”的访问授权的方法，默认拒绝任何人的访问。访问许可必须被显式地赋予访问者。

##### 1.2.1.2 “自主（Discretionary）控制”的体现

拥有对象权限的用户，可以将该对象的权限分配给其他用户

##### 1.2.1.3 常见的使用场景

文件系统的权限设计，例如下图所示：

![img](https://upload-images.jianshu.io/upload_images/594774-6d77f13cc568797f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/698/format/webp)

##### 1.2.1.4 优缺点

**优点**

简单，用户具有自主权

**缺点**

- 对权限控制比较分散，不便于管理

- 被某个用户执行的程序拥有与该用户相同的权限。这意味着系统安全依靠运行的程序，当一个程序中发生安全裂缝，会影响到该用户能访问的所有对象。这使得DAC在特洛伊木马(**借尸还魂，或者内外勾结，将其他当前用户可访问的文件统统拷到指定的文件中盗走**)前特别脆弱。

#### 1.2.2 强制访问控制（MAC: Mandatory Access Control）

##### 1.2.2.1 起源

MAC是为了弥补DAC权限控制过于分散的问题而诞生的。

##### 1.2.2.2 基本流程

在MAC的设计中，每一个对象都都有一些权限标识，每个用户同样也会有一些权限标识，而用户能否对该对象进行操作取决于双方的权限标识的关系，这个限制判断通常是由系统硬性限制的。（**简单理解：双方都有权限标识，由系统硬件根据双方权限确定是否能够操作**）

在MAC这种模型里，**管理员管理访问控制**。管理员制定**策略**，用户不能改变它。策略定义了**哪个（哪类）主体能访问哪个（哪类）对象**。这种访问控制模型可以增加安全级别，因为它基于策略，任何没有被显式授权的操作都不能执行。

比如在影视作品中我们经常能看到特工在查询机密文件时，屏幕提示需要“无法访问，需要一级安全许可”，这个例子中，文件上就有“一级安全许可”的权限标识，而用户并不具有。

##### 1.2.2.3 使用场景以及不适用场景

**适用场景：**非常适合机密机构或者其他等级观念强烈的行业

**不适用场景：** 对于类似商业系统，其不够灵活而不能够适用

#### 1.2.3 基于角色的访问控制（RBAC: Role-Based Access Control)

**产生原因：**同行给饭吃，DAC和MAC的具有诸多限制。利用RBAC可以模拟出DAC和MAC的效果。

RBAC认为权限的过程可以抽象概括为：**判断【Who是否可以对What进行How的访问操作（Operator）】这个逻辑表达式的值是否为True的求解过程。**

##### 1.2.3.1 基本概念

![img](https://upload-images.jianshu.io/upload_images/594774-b220fc093138a2c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp)

RBAC模式在用户和权限之间引入了“角色（Role）”的概念，每个用户关联一个或多个角色，每个角色关联一个或者多个权限。角色可以根据实际的业务需求灵活创建，这样就省去了新增一个用户需要关联一遍所有权限的麻烦。简单来说RBAC就是：**用户关联角色，角色关联权限**。

##### 1.2.3.2 使用RBAC模型的例子

例如数据库软件MongoDB便是采用RBAC模型，对数据库的操作都划分成了权限（[MongoDB权限文档](https://link.jianshu.com?t=https://docs.mongodb.com/manual/reference/privilege-actions/)）：

| 权限标识  | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| find      | 具有此权限的用户可以运行所有和查询有关的命令，如：aggregate、checkShardingIndex、count等。 |
| insert    | 具有此权限的用户可以运行所有和新建数据有关的命令：insert和create等。 |
| collStats | 具有此权限的用户可以对指定database或collection执行collStats命令。 |
| viewRole  | 具有此权限的用户可以查看指定database的角色信息。             |
| …         |                                                              |

基于这些权限，MongoDB提供了一些预定义的角色（[MongoDB预定义角色文档](https://link.jianshu.com?t=https://docs.mongodb.com/manual/reference/built-in-roles/)，用户也可以自己定义角色）：

| 角色      | find | insert | collStats | viewRole | …    |
| --------- | ---- | ------ | --------- | -------- | ---- |
| read      | ✔    |        | ✔         |          | …    |
| readWrite | ✔    | ✔      | ✔         |          | …    |
| dbAdmin   | ✔    |        | ✔         |          | …    |
| userAdmin |      |        |           | ✔        | …    |

最后授予用户不同的角色，就可以实现**不同粒度的权限分配**了。

##### 1.2.3.5 适用场景

目前市面上绝大部分系统在设计权限系统时都采用RBAC模型。

##### 1.2.3.4 RBAC的错误使用用法

他们采用的是**判断用户是否具有某个角色而不是判断权限。**

**这种错误用法会导致的问题：**业务逻辑和角色进行了强捆绑，在业务逻辑修改时需要修改代码，例如设计一个角色hr，其具有给员工涨薪水的权限，如果后期公司规定部门经理也可以给员工涨薪，这时就不得不修改代码了。

##### 1.2.3.5 角色继承(Hierarchical Role)

![img](https://upload-images.jianshu.io/upload_images/594774-386977fee82f6152.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/503/format/webp)

顾名思义，角色继承就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。

##### 1.2.3.6 职责分离(Separation of Duty)

**目的：**为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？）

职责分离有两种模式：

- 静态职责分离(Static Separation of Duty)：用户**无法同时被赋予有冲突的角色**。

![img](https:////upload-images.jianshu.io/upload_images/594774-feb7c1074d151113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp)

- 动态职责分离(Dynamic Separation of Duty)：用户在**一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一**。

![img](https:////upload-images.jianshu.io/upload_images/594774-059b93e4209e8fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/397/format/webp)

##### 1.2.3.7 用户和对象的权限控制

###### 1.2.3.7.1 RBAC标准中没有涉及的问题

讲了这么多RBAC，都只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。例如华中区域的销售没有权限查询华南区域的客户数据，虽然他们都具有销售的角色，而销售的角色拥有查询客户信息的权限。
###### 1.2.3.7.2  解决方案

两种方式：

- 在判断用户是否具有权限的基础上更进一步判断了用户是否有权限操作这个特定的对象，并且这个判断逻辑是通过代码设置的，非常灵活，但同时也会带来额外的开发和维护成本。
- 基于模式匹配规则的对象权限控制，不够灵活但是在很多场景中已经够用了

##### 1.2.3.8 通俗的解释

基于角色的访问控制（RBAC），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。RBAC认为权限授权实际上是Who、What、How的问题。在RBAC模型中，who、what、how构成了访问权限三元组,也就是“Who对What(Which)进行How的操作”。

Who：权限的拥用者或主体（如Principal、User、Group、Role、Actor等等）

What：权限针对的对象或资源（Resource、Class）。

How：具体的权限（Privilege,正向授权与负向授权）。

Operator：操作。表明对What的How操作。也就是Privilege+Resource

Role：角色，一定数量的权限的集合。权限分配的单位与载体,目的是隔离User与Privilege的逻辑关系.

Group：用户组，权限分配的单位与载体。权限不考虑分配给特定的用户而给组。组可以包括组(以实现权限的继承)，也可以包含用户，组内用户继承组的权限。User与Group是多对多的关系。Group可以层次化，以满足不同层级权限控制的要求。

RBAC的关注点在于Role和User, Permission的关系。称为User assignment(UA)和Permission assignment(PA).关系的左右两边都是Many-to-Many关系。就是user可以有多个role，role可以包括多个user。

##### 1.2.3.9 RBAC支持的安全原则

- **最小特权原则**得到支持，是因为在RBAC模型中可以通过限制分配给角色权限的多少和大小来实现，分配给与某用户对应的角色的权限只要不超过该用户完成其任务的需要就可以了。
- **责任分离原则**的实现，是因为在RBAC模型中可以通过在完成敏感任务过程中分配两个责任上互相约束的两个角色来实现，例如在清查账目时，只需要设置财务管理员和会计两个角色参加就可以了。
- **数据抽象是借助于抽象许可权**这样的概念实现的，如在账目管理活动中，可以使用信用、借方等抽象许可权，而不是使用操作系统提供的读、写、执行等具体的许可权。但RBAC并不强迫实现这些原则，安全管理员可以允许配置RBAC模型使它不支持这些原则。因此，RBAC支持数据抽象的程度与RBAC模型的实现细节有关。

##### 1.2.3.10 RBAC96模型族中包括的RBAC0~RBAC3四个概念性模型

###### 1.2.3.10.1 RBAC0 定义了完全支持RBAC概念的任何系统的最低需求

四个核心部分：用户（User）、角色（Role）、许可（Permission，操作（Operation）+对象（Object））、会话（Session）

![bubuko.com,å¸å¸æ£](http://images.cnitblog.com/blog/453361/201406/171727281766655.png)

**角色：**每个角色至少具备一个权限，每个用户至少扮演一个角色。不同的角色可以分配相同的访问控制。

**会话：**可以创建会话并激活多个用户角色，从而获得相应的访问权限，可以在会话中更改激活角色，用户可以主动结束一个会话。

**两个多对多联系:**

- 用户-角色，
- 角色-许可，

###### 1.2.3.10.2 RBAC1，在RBAC0的基础上增加角色分级的概念

基于RBAC0模型，引入角色间的继承关系，即角色上有了上下级的区别。

![bubuko.com,å¸å¸æ£](http://images.cnitblog.com/blog/453361/201406/171728216451623.png)

**继承关系：**

- **一般继承关系：**仅要求继承关系是一个绝对偏序关系，允许角色间的多继承
- **受限继承关系：** 进一步要求角色继承关系是一个树结构，实现角色间的单继承

###### 1.2.3.10.3 RBAC2，在RBAC0的基础上增加限制（不同组件中配置方面的限制）

RBAC2模型中添加了**责任分离关系**。RBAC2的约束规定了权限被赋予角色时，或角色被赋予用户时，以及当用户在某一时刻激活一个角色时所应遵循的强制性规则。

**约束作用的时机：**

- 权限被赋予角色时
- 角色被赋予用户时
- 当用户在某一时刻激活一个角色时

**责任分离类型**

- 静态责任分离（SSD），约束的情形下（例如冲突）不允许分配

- 动态责任分离（DSD），互相形成约束的情形下（例如冲突）仅允许激活一种

**约束+用户-角色-权限====决定====> 用户的访问许可**

**约束的类型**

- **互斥角色（）**，同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自**权限互相制约的两个角色**。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。
- **基数约束**，一个角色**被分配的用户数量受限**；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。例如公司的领导人有限的；
- **先决条件角色**，可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。就像我们生活中，国家主席是从副主席中选举的一样。
- **运行时互斥**，例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。

![bubuko.com,å¸å¸æ£](http://images.cnitblog.com/blog/453361/201406/171728227547295.png)

用户和角色之间的约束如下图中所述。个人觉得，角色和许可之间的约束与之类似，但是仅为一项约束，不适合用来处理职责分离，在许可分配给角色时满足约束。

![bubuko.com,å¸å¸æ£](http://images.cnitblog.com/blog/453361/201406/171728237709238.png)

###### 1.2.3.10.4 RBAC3称为统一模型，它包含了RBAC1和RBAC2，利用传递性，也把RBAC0包括在内。

![bubuko.com,å¸å¸æ£](http://images.cnitblog.com/blog/453361/201406/171727180204418.png)

![bubuko.com,å¸å¸æ£](http://images.cnitblog.com/blog/453361/201406/171728251147982.png)



##### 1.2.3.11 RBAC的优缺点

**优点**

- 

**缺点：**

- RBAC模型**没有提供操作顺序控制机制**。这一缺陷使得RBAC模型很难应用关于那些要求有严格操作次序的实体系统。

##### 1.2.3.12 角色和用户组的区别？

- 用户组是**用户的集合**，但不是许可权的集合；
- 角色却同时具有**用户集合和许可权集合的概念**，角色的作用把这两个集合联系在一起的中间媒介。

#### 1.2.4 基于属性的权限验证（ABAC: Attribute-Based Access Control）

ABAC被一些人称为是权限系统设计的**未来**。ABAC有时也被称为PBAC（Policy-Based Access Control）或CBAC（Claims-Based Access Control）。

##### 1.2.4.1 基本概念

不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是**通过动态计算一个或一组属性来是否满足某种条件来进行授权判断（可以编写简单的逻辑）**。理论上能够实现非常灵活的权限控制，几乎能满足所有类型的需求。

**属性分类**

- 用户属性（如用户年龄）
- 环境属性（如当前时间）
- 操作属性（如读取）
- 对象属性（如一篇文章，又称资源属性）

##### 1.2.4.2 例子

例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。为了实现便捷的规则设置和规则判断执行，ABAC通常有配置文件（XML、YAML等）或DSL配合规则解析引擎使用。

##### 1.2.4.3 ABAC的特点

**优点**

1. **集中化管理**
2. 可以按需实现**不同颗粒度的权限控制**
3. **不需要预定义判断逻辑**，减轻了权限系统的维护成本，特别是在需求经常变化的系统中

**缺点**

1. 定义权限时，不能直观看出用户和对象间的关系（**权限不直观**）
2. 规则如果稍微复杂一点，或者设计混乱，会给管理者维护和追查带来麻烦（**设计以及维护麻烦**）
3. 权限判断需要实时执行，规则过多会导致性能问题（**性能相对弱**）

##### 1.2.4.4 为啥不大面积使用ABAC呢？

**一种理解：**主要还是因为大部分系统对权限控制并没有过多的需求，而且ABAC的管理相对来说太复杂了

##### 1.2.4.5 ABAC授权的步骤

•1、用户访问资源，发送原始请求。

•2、请求发送到策略实施点（PEP），PEP构建xacml格式请求。

•3、PEP将xacml请求发送到策略决策点（PDP）。

•4、PDP根据xacml请求，查找策略管理点（PAP）中的策略文件。

•5、PDP从策略信息点（PIP）查找策略文件中需要的属性值（主体、资源、环境属性）。

•6、PDP将决策结果（permit、deny、不确定、不适用）返回给PEP。

•7、PEP发送请求到资源，并把资源返回给用户。

![img](https://img-blog.csdn.net/20180820104708242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jsb2dfZW1waXJl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 1.2.4.6 策略文件组成

然后就是策略文件的构成，策略文件是非常重要的文件，所有的决策都是根据策略文件来判断的

![img](https://img-blog.csdn.net/20180820105005629?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jsb2dfZW1waXJl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 策略文件的组成包括几部分，目标、规则。

#### 1.2.5 基于资源的权限控制（Resource Based Access Control）

**使用基于资源的方式，仍然是需要角色的**，用户的**权限分配的依据往往是角色**（比如：如果我给你admin角色，那么同时也会给你curd的权限）。而进行**访问控制时，则不依赖角色，而是直接查看是否具有资源的当前操作权限**（比如：你想查看 ，那么我可以直接问你你有retrieve权限吗？如果有，你就可以访问。而不关心你是什么角色）。所以严格上将其只是基于角色的权限控制的一个特例，也称为强角色模式。

**两类角色：**

- 隐式角色：直接通过角色来验证用户有没有操作权限，粒度较粗，可能需要修改代码
- 显示角色：在程序中通过权限控制谁能访问某个资源，即角色只是组合了一堆权限，不作为校验的粒度每次直击具体资源，粒度较细。

1、隐式角色的访问控制

由于基于角色的权限访问控制的角色与权限往往是多对多的关系（比如admin角色可以所有CURD的权限，部门经理角色有Retrieve权限，这就是多对多关系了），如果角色所对应的权限发生变化 ，那我们所编写的判断逻辑就必须发生改变，可扩展性差。

2、显式资源的访问控制

如果是基于资源的权限访问控制，资源和权限一对一关系比较常见，很多时候资源和权限在数据库中会被合并在一张表中，只需要为资源分配相应的权限。所以一个具体操作对应的权限，只要直接判断用户是否拥有该权限即可，可扩展性强

### 1.3 各种设计模式之家的关系

现代操作系统**组合使用了上述的访问控制模型**。尽管Windows NT没有实际使用RBMC，它使用内建的组实现了类似的模型，如Power Users，Server Operators，Backup Operators。管理员可以根据作业的行为增加额外的角色。拥有适当权限的用户可以分享资源，如文件和打印机，而且与DAC模型相应的，自主决定给与其它用户和组访问权。

## 2. 权限管理系统的分析和构建

根据权限的表现方式，权限管理包括：

- 控制用户访问某些功能、
- 控制用户访问某些数据

系统中的核心部分及其对应的联系如图所示：

![img](https://upload-images.jianshu.io/upload_images/8369174-86f84817576ed463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**核心点：**

- 用户的身份标识-以及类别----->通过账号体现
- 权限
  - 功能权限：对象级功能（某块功能可与否）、操作点权限（可操作性与否）、字段权限（展示与否）
  - 数据权限，代表数据私有、公开读、公开读写，以及数据的共享问题
- 角色 ，一类权限的组合，简化分配权限时的操作
- 权限校验规则（虽然没有提及，但是这是一个关键点）

### 2.1 控制系统的账号及登陆

账号是用户身份的证明。

#### 2.1.1 账号分类

- 普通员工账号
- 管理员账号

#### 2.1.2 账号状态

账号的状态用于标识账号的合法性，账号是进行权限校验的第一步，通过禁止处于不合法状态的账号使用，能够过滤大量的非法访问。常见的两个账号状态为：

1）帐号禁用：在登录系统时多次输入密码错误,系统会因为帐号安全问题暂时把禁用掉。或涉及到帐号被盗等场景需立马禁用，修改密码等操作。
2)   帐号停用：员工离职，但是在职时所有的操作记录信息还存在，所以设置为停用。

### 2.2 角色管理

角色往往是基于业务管理需求而预先在系统中设定好的固定标签，每个角色对应明确的系统权限，他是一个集合的概念，是众多最小权限颗粒的组成。我们通过把权限给这个角色，再把角色给账号，从而实现账号的权限，因此它承担了一个桥梁的作用。引入角色这个概念，可以帮助我们灵活的扩展，使一个账号可以具备多种角色。

![img](https://upload-images.jianshu.io/upload_images/8369174-02d47507991e1aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.3 控制功能权限

控制功能权限管理：底层菜单管理配置一般为开发人员一早就配置好。现在由用户进行分配使用这些功能权限。功能权限：以角色为基础，通过划分不同角色的不同功能权限，并将员工添加到对应的角色中，实现员工功能权限的区分和隔离，包括：
●对象级功能：比如功能的入口是否可见，如角色为“蓝鲸观察者”，对象“人员管理”的“查看列   表”权限点取消，则此角色下员工不可见人员管理的功能入口。
●操作点权限：比如新建、编辑等业务操作；
●字段权限：在展示信息时加权限控制，保证敏感信息的安全性。

### 2.4 控制数据权限

1、基础数据权限：即根据数据的负责人来决定，具体权限包括：私有、公开只读、公开读写

2、数据共享：根据基础数据权限中的数据记录所属将其共享给其它用户查看或编辑。

### 2.5 权限管理的理解

权限管理需要控制的其实是**用户可以进行的行为的关联关系**

上句话涉及的东西：用户、行为、关联关系

**关于用户**

- 用户是怎么**分类**的（用户角色） 

- 用户和用户之间是否有**关系**？如果有，是什么关系？**关系是什么结构**的？

- - 如公司组织架构那种层级分明的树形结构

**关于行为**

- 怎么将行为**分类**（一般来说按照行为目的区分、按照行为业务类别区分、按照行为与系统的交互类型区分）

- - 例如，按照行为与系统的交互类型区分

  - - 数据权限：指的是用户有权操作的那部分数据（读、写）
    - 功能权限：对使用人群在功能修改使用等方面权利的限制

- 行为之间是否有层级和依赖关系，是怎么样的依赖关系

**关于关联关系**

- 是一对一还是一对多，如果有父子层级之分，是继承关系还是独立存在。

**一句话概括就是：权限系统维护的是人和可进行行为的关联关系。**

那么系统的每个用户可以看做是一堆可以进行的行为的集合。这句话有点不好理解的话，你就按照用户画像那么理解，在权限系统里，每个用户身上打满了一堆可以进行行为的标签。

![img](https://pic4.zhimg.com/80/dedc9917bf9a5380f155424ddb79e3c3_hd.png)

那么权限控制系统的原理呢？ 其实很简单，就是： **用户在访问时，通过了解用户具有的可以进行的行为的集合，决定用户可以看到什么菜单，以及在什么菜单下能使用什么功能，并且具备什么样操作数据的能力。**

### 2.6 规范化权限控制（东西是好东西，但是不好看懂）

权限的最简单方式为硬编码方式，在用户发起请求时随接口做一层权限验证，或者是对数据库读写限制权限，但是这种方式对于产品迭代的情境下，是不能被接受的，这是需要引入一个模式来规范化权限控制。

#### 2.6.1 结构化管理

**简单理解：利用装饰器模式，将权限校验装饰在操作之上**

通过以上情景，我们很容易得到一种权限结构模型（参考 django）以 user（单一用户）、group（用户组）、permissions（单一权限）三层两两之间多对多的关系，实现了当用户请求接口 APIa，此时进行获取用户，获取用户所属组，获取所属组所具备的权限，若获取不到记录，则限制掉此次请求。运用这个模型，我们每次将 permissions 定义成：module、function 的形式，同时定义 request method 。这样将具有权限的 group 关联到一个 permission（即一个 handler）上。同时将用户关联到用户组，从而可以在不断变动权限的情况下，配置一次对应关系，将用户权限限制到单个 handler 上。

![img](https://pic2.zhimg.com/v2-18f4123d36facca3dc265c92de834f59_b.jpg)![img](https://pic2.zhimg.com/80/v2-18f4123d36facca3dc265c92de834f59_hd.jpg)

用 python 的同学知道，由于 python decorator @的语法糖，我们很喜欢用这种形式来处理这些与业务逻辑无关的代码，例如：日志记录、检查缓存、检查 user session等。有时候在一个方法装饰器写的像盖楼一样，稍不留神就忘记了。有时候开发者对项目不熟悉，在写一个新的接口之后，配置了权限，却忘记加装饰器，导致这部分一直没有被限制。

```text
@route()
@login_required
@check_cache
@add_log
@permission_verify
@transaction.atomic
def interface_a():
```

所以在这里引入一个中间件，专门处理这个事情，不必每次增加额外代码。

中间件运行发生在后端 route dispatching 的时候，每次的请求我们根据请求的 session 找到 user、找到对应的 user group, 再找到 permissions，**通过定义的具有权限 module function 与请求的 handler 比对，若不同则限制掉。**

```text
def permission_middleware():
   permissions =  request.get.user_permissions()
   if ‘{}_{}’.format(handler.__class__, handler.func_name) not in permissions:
       return permission_denied
```

这样后端限制逻辑比较结构化，节省了很多麻烦，**方便修改和管理。同时具有较好的扩展性**，我们将 user 定义为单一用户对象，将 permissions 看作单一 handler 对象，可以把所有门店、部门、小组、小群体等均划分到 group 一层 。几乎大部分的业务需求均可以对应实现。逻辑准确，嗯，很完美。

#### 2.6.2 限制闭环，对象细化

**简单理解：将权限具体细化到资源或者对象上**

![img](https://pic1.zhimg.com/80/v2-c4f6a8740e6fd62c897b7cb5acd1d528_hd.jpg)

第二天 PM 来了，说 xx 部门的小 x 讲他们部门里面的工作内容需要分类，（我在点头，心里想：嗯嗯，我给你们每一个分类加一个 group 配置 user 权限）一个工作分类有许多工作者，有一个管理者，管理者需要看所有工作者的工作进度，工作内容管理者也同样可以进行（心里想：嗯嗯，我再加一个管理者的 group 所有权限一样，单独加一个工作进度查看的权限）同时！1分类下的管理者，还可以看2、3工作分类下的小 y 小 z 的工作进度！（我心里想：what？这不科学吧）PM 继续说，因为他们工作要对接，是需要查看的功能（我想：那管理者不作分类不就好了，所有的内容都可以看）并不能全部看到！PM 接着说，他的主要工作还是本分类下的工作内容，只是查看一下其他分类下的几个人的进度，你不能给他把所有人的内容都展示出来吧，况且有些还是保密的。

这确实是一个问题，不仅仅是在这种特殊的情况，只要涉及到针对某一个用户，或者某一个具体内容做操作限制，就是实现不了的。经过辗转反侧，发现我们之前做的只是将权限限制在操作行为上，没有形成闭环，操作哪些对象没有定义。每一次限制默认是所有对象。这样虽然方便管理，但是有些场景不能满足需求。于是引入**权限操作对象范围**的概念：

在之前的 permissions 一层上加入：

\1. 是否有对象粒度限制

\2. 限制的哪个 model 的 object

\3. 可操作的object id list。

由于这部分是对于数据过滤的处理，所以我们无法在中间件完成这个操作。将这部分**放入数据处理层（DAO 层）进行过滤**是个不错的主意。首先我们在数据处理方法中，在上下文获取本次请求的 user 对象，按老办法将他的 permissions 统统获取到，这时，按照我们预先定义的：是否有对象粒度限制进行判断，需要限制则根据当前处理的 model 过滤出操作的 object id list。这样在返回数据的时候，所有记录均为对其具有操作权限的对象。

```text
object_id_list = request.user.permissions.get_object_id_list()
if need_limit_object and model == request.user.permissions.get_model:
       sql = ‘select * from model where id in {}’.format(tuple(object_id_list))
       return fetch_data(sql)
```

现在我们满足了所有（至少是目前为止所遇到的）业务需求，后续权限的所有需求也可以按照这个思路进行相关配置处理，并得以解决（美好的愿望^_^）。

#### 2.6.3 前端限制提高体验

**简单理解：没权限还让我点个球球呦！没权限就不给看了呗，屏蔽不可用不就好了，烦人！**

至此，我们开发工作会变得很愉快，逻辑清晰且结构严谨。与此同时，给 c 端用户的体验就是，哪里不会点哪里，点完哪里不给你。给一个美如画的页面或者是弹窗还算好的，跳个403、404或是500想必也见过。此时用户只有一句 mmp，什么破玩意不玩了。

![img](https://pic3.zhimg.com/v2-39ca278452a756d11a23cbb9b291a892_b.jpg)![img](https://pic3.zhimg.com/80/v2-39ca278452a756d11a23cbb9b291a892_hd.jpg)

所以，权限在前端预先限制势在必行，好在我们多数情况下用到了**模版引擎**，很方便的在页面上进行权限判断。在服务器端渲染页面的时候，根据当前请求的用户，获取到所有权限，在某一个 DOM 上简单随意的写上一句判断代码，将我们在中间件中匹配 handler 的过程放到模版渲染的过程，这样将没有权限的条目过滤掉，还用户一个清静的世界，同样可以避免点到不该点的东西。

```text
{% if user.permissions.can_modify_xxx %}
<a href=”/modify_xxx/”>修改xxx</a>
{% endif %}
```

如果是在不用模版引擎的情况下，我们就需要在页面在浏览器渲染的时候，加一个 ajax 请求加载到用户的权限列表，用js后期去掩盖掉不该看到的东西。

#### 2.6.4 前端组件化管理

**简单理解：组件化然以便复用**

这样极大程度的提高了用户体验，但是回顾一下我们的做法，编写一个新的功能，处理掉权限所有关系配置之后，需要根据这个 module function 字符串在页面上所有用到的地方写一句判断语句，这样非常麻烦。而且如果想要修改一个权限的定义，简直是灾难。为了解决这个问题，我们不得不借鉴一下**组件化的设计模式，即模版复用。**用模版引擎的继承、导入可以实现这个目的。当然 react 是天生的组件化设计理念。我们在一个最上级组件初始化的时候将该用户具有的权限列表从服务器端拉取，存储本地，然后依次向下流入到各级子组件中，每个组件配置一个 id（可以与 module function 字符串一致，也可以做一次映射）当组件在权限列表中找到自己的对应的 id 则进行渲染。最终整个页面根据权限列表将所有可以显示的部分全部渲染出来。

![img](https://pic4.zhimg.com/v2-e3acd17cb9272a315fb1f3580019687f_b.jpg)![img](https://pic4.zhimg.com/80/v2-e3acd17cb9272a315fb1f3580019687f_hd.jpg)

刚才提到的组件id这是前后端限制的关键，后端根据 module function 判断 handler 处理，前端根据 id 判断渲染与否，那么这个配置应该是前端写好组件由后端配置，还是后端提供配置权限入口，由前端自行配置呢？

#### 2.6.5 前后端分工配合

当我们讨论开发模式的时候，总会遇到这样一个问题：

**前后端分离还是不分离**

- 分离时前端工作量加重，路由、组件加载、部署等都要处理，有时候项目不是很大，这种分离得不偿失，但是好处是前后端各司其职，处理自己的部分，不会产生不必要的工作量。
- 不分离的情况就是运用模版引擎，前端提供静态页面，服务器端渲染，这样有的时候在后端处理数据的同时可能将页面样式或者动画效果破坏掉，然后又要两端反复修改，好处是开发简单，一些功能简单且比较单一，可以直接一并处理。

无论分离还是不分离，**提供一个配置服务这个中间产物**是有必要的，分离时我们可以让前端在写好组件后，将自己的组件id配置在系统中，后端按照正常的限制逻辑进行。不分离时，直接根据前端页面的编写的 id 进行配置，这部分可以由后端完成。有了这个公共区的系统，想必大家都是很开心的，又能一起愉快的玩耍（coding）了。现在处理这个问题的开源项目有很多，比如基于 django admin、flask admin 等流行的后台管理项目，就可以很好的搭建这种定制化的公共配置部分。

当然，具体的设计结构需要**根据系统需求作相应的变通**，可能有些场景限制粒度无要求，我们可以不作操作对象的闭环，如果是权限严格要求的场景（Mario 遇到的场景）就显得有必要了。前端限制在**追求用户体验**的情况是有必要的，**组件化**会将结构理得非常清晰，同时工作量也有所增加。公共区的配置模块就像一个前后端的枢纽，或者说是一个契约，不仅是在权限限制上，在所有配合开发的场景都是有所帮助的。

### 2.7 AOP与权限管理

#### 2.7.1 AOP

##### 2.7.1.1 AOP理解

AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。

**AOP真正目的是，你写代码的时候，事先只需考虑主流程，而不用考虑那些不重要的流程，不重要的流程写到另外的地方通过代理方式在某个方法调用时、前、后增加**

在一个银行的存取款业务中，都有一个前置的相同操作，验证用户，我们可以把这个相同的操作首先提取出来，可以作为一个公共的方法（模块）进行调用，但是现在具有一个问题，每次还是需要写一堆业务逻辑代码调用，并且我就想取个钱，一上来就让我想这么多，我可能就在身份验证时就需要修改密码去了，还取什么钱，那是要写修改密码逻辑还是写取钱逻辑？？所以，如何让他们每次在这个位置都自己去调用呢？显然是可以，代理模式，如果可以在保证在操作执行之前需要先执行代码块，那么把验证逻辑放进这个先执行代码块，那显然可以达到目的。另外这些先做代码（代码中实现指定的逻辑）都是在流程中切入进去，那么切点连起来就是一个切面了（面不平，有的先到，有的后到）。

![img](http://static.oschina.net/uploads/img/201402/26210700_pnBX.jpg)

所以AOP的**本质是在一系列纵向的控制流程中，把那些相同的子流程提取成一个横向的面**，这句话应该好理解吧，我们把纵向流程画成一条直线，然把相同的部分以绿色突出，如下图左，而AOP相当于把相同的地方连一条横线，如下图右，这个图没画好，大家明白意思就行。

![img](http://static.oschina.net/uploads/img/201402/26210700_Oo8W.jpg)![img](http://static.oschina.net/uploads/img/201402/26210702_DV25.jpg)

##### 2.7.1.2 AOP 基本概念

(1)Aspect(切面):通常是一个类，里面可以定义切入点和通知

(2)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用

(3)Advice(通知):AOP在特定的切入点上执行的增强处理，有before,after,afterReturning,afterThrowing,around

(4)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式

(5)AOP代理：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类

**个人简单比喻，不一定准确：**切面可以比喻为收费站（有位置+有收费服务）；连接点为具体的高速路入口地址；通知为收费服务：先交钱+数钱够不？+后放行；切入点为把收费服务放置在高速路口，嘿嘿，你想过就得走流程交钱。AOP代理是ETC（不停车自动收费），每次一走这个车道，畅通无阻，以为不收费了，哈哈，SB，电子系统已经帮你自动代理了，嘿，小伙，来了，直接走吧，钱自动扣完了。

#### 2.7.2 代理

![img](https://images2015.cnblogs.com/blog/1085268/201704/1085268-20170409105440082-1652546649.jpg)

##### 2.7.2.1 分类：

###### 2.7.2.1.1 静态代理

直接通过硬编码的方式，生成代理对象，在被代理对象的操作做增强处理

###### 2.7.2.1.2 动态代理

代理类在程序运行时创建的代理方式被成为动态代理。

具有两种实现方式：

- **java动态代理（通过接口+重载）**，被代理对象需要实现JDK提供的动态代理接口。

JDK动态代理所用到的代理类在程序**调用到代理类对象时才由JVM真正创建**，JVM根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。

- **cglib（通过继承+重写）**，该方法只需要对目标对象继承即可。

cglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。 

###### 2.7.2.1.3 Java动态代理原理

jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。

我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。

代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。

###### 2.7.2.1.4  各种代理模式的实现方法

实现核心：

- **静态**

使用额外的类对其进行包装，在调用方法之前进行具体的代理操作。

- **java动态代理**

1. 实现InvocationHandler接口，重写

```java
public Object invoke(被代理对象, Method, 方法参数数组) throws Throwable{}
```

2. 包装代理

```java
Proxy.newProxyInstance(被代理对象的类加载器, 被代理对象实现的接口数组, 实例化InvocationHandler);
```

- **CGLIB实现**

1. 导入cglib类库
2. 实现MethodInterceptor接口，重写

```java
public Object intercept(被代理对象, Method, 方法参数数组, MethodProxy) throws Throwable{}
```

3. 包装代理

```java
Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类
enhancer.setSuperclass(代理对象的Class);  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）
//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦
enhancer.setCallback(实现MethodIntercept接口的实例);
// 创建动态代理类对象并返回，当被代理使用的是无参构造函数时
enhancer.create(); 
//当被代理使用的是有参构造函数时使用这个方法
// enhancer.create(被代理对象构造参数Class数组，被代理对象构造参数值数组); 
```

**Demo(文件名TestAgent.java)**

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Person {
    //上交班费
    void giveMoney();
}

class Student implements Person {
    private String name;

    //cglib 模式下无参构建方式（create时没有参数）中使用
    public Student() {}

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName() {
        this.name = name;
    }

    @Override
    public void giveMoney() {
        System.out.println(name + "上交班费50元");
    }
}

//学生代理类
class StudentsProxy implements Person{
    //被代理的学生
    Student stu;

    public StudentsProxy(Person stu) {
        // 只代理学生对象
        if(stu.getClass() == Student.class) {
            this.stu = (Student)stu;
        }
    }

    //代理上交班费，调用被代理学生的上交班费行为
    public void giveMoney() {
        System.out.println("家长来交钱了");
        stu.giveMoney();
    }
}

// 学生代理类
class StuInvocationHandler<T> implements InvocationHandler {
    //invocationHandler持有的被代理对象
    T target;

    public StuInvocationHandler(T target) {
        this.target = target;
    }

    /**
     * proxy:代表动态代理对象
     * method：代表正在执行的方法
     * args：代表调用目标方法时传入的实参
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("代理执行" +method.getName() + "方法");
        Object result = method.invoke(target, args);
        return result;
    }

    // 生成代理的方法
    public static<T> T getProxy(T target) {
        InvocationHandler stuHandler = new StuInvocationHandler<T>(target);
        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
        Person stuProxy = (Person) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), stuHandler);
        return (T)stuProxy;
    }
}

class StuCglib<T> implements MethodInterceptor {
    private T target;//业务类对象，供代理方法中进行真正的业务方法调用

    public StuCglib(T target) {
        this.target = target;
    }

    public T getTarget() {
        return this.target;
    }

    // 实现回调方法
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("预处理——————");
        proxy.invokeSuper(obj, args); //调用业务类（父类中）的方法
        System.out.println("调用后操作——————");
        return null;
    }

    //相当于JDK动态代理中的绑定
    public static<T> T getProxy(T target) {
        StuCglib<T> instance = new StuCglib<>(target);  //给业务对象赋值
        Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类
        enhancer.setSuperclass(instance.getTarget().getClass());  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）
        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦
        enhancer.setCallback(instance);
        // 创建动态代理类对象并返回
        return (T)enhancer.create();
    }

    //相当于JDK动态代理中的绑定,带参数版本
    public static<T> T getProxy(T target, Class[] constructArgClass, Object[] constructArgValue) {
        StuCglib<T> instance = new StuCglib<>(target);  //给业务对象赋值
        Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类
        enhancer.setSuperclass(instance.getTarget().getClass());  //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）
        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦
        enhancer.setCallback(instance);
        // 创建动态代理类对象并返回
        return (T)enhancer.create(constructArgClass, constructArgValue);
    }
}

public class TestAgent {
    public static void main(String[] args) {
        Student person = new Student("zhang ");
        //静态代理
        System.out.println("静态代理");
        StudentsProxy studentsProxy = new StudentsProxy(person);
        studentsProxy.giveMoney();

        //java动态代理
        System.out.println("java动态代理");
        Person person1 = StuInvocationHandler.getProxy(person);
        person1.giveMoney();

        System.out.println("cglib动态代理实现");
        //带构造参数
        Person person2 = StuCglib.getProxy(person, new Class[]{String.class}, new Object[] {person.getName()});
        person2.giveMoney();
        // 不带构造参数
        Person person3 = StuCglib.getProxy(person);
        person3.giveMoney();
    }
}

```

#### 2.7.3 AOP与权限校验

实现功能权限校验的功能有多种方法，其一使用拦截器拦截请求，其二是使用AOP抛异常。

##### 2.7.3.1 拦截器实现权限校验

使用拦截器实现未登录时跳转到登录界面的功能。注意这里没有使用AOP切入，而是用拦截器拦截，因为AOP一般切入的是service层方法，而拦截器是拦截控制器层的请求，它本身也是一个处理器，可以直接中断请求的传递并返回视图，而AOP则不可以。

**这里需要特别说明**：拦截器拦截的路径最好是带有后缀名的，否则一些静态的资源文件不好控制，也就是说请求最好有一个统一的格式如 .do 等等，这样匹配与过滤速度会非常快。如果不这样，例如 用 /** 来拦截所有的请求，则页面渲染速度会非常慢，因为资源文件也被拦截了。

##### 2.7.3.2 使用AOP抛异常的方式实现权限校验

AOP切入的是方法，不是某个控制器请求，所以不能直接返回视图来中断该方法的请求，但可以通过抛异常的方式达到中断方法执行的目的，所以在before通知中，如果通过验证直接return返回继续执行连接点方法，否则抛出一个自定义异常AccessDeniedException来中断连接点方法的执行。该异常的捕获可以通过系统的异常处理器（可以看做控制器）来捕获并跳转到一个视图或者一个请求。这样就达到拦截请求的目的。所以需要配置异常处理器。

## 3. Shiro权限管理框架

Apache Shiro是Java的一个安全框架，其自带会话机制，不仅能够在java SE环境使用，同时也能在java EE环境使用。

**记住一点，Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。**

两个容易混的单词：

- AuthenticationInfo代表了用户的角色信息集合，
- AuthorizationInfo代表了角色的权限信息集合

Shiro框架的学习见[《跟我学Shiro》PDF完结版下载](https://jinnianshilongnian.iteye.com/blog/2049092)，下面个内容不完整，如果想要研究明白具体看这个系列博客，看完最起码需要好几天，如果时间不够就挑核心。

### 3.0 自认为的重要知识点

- 基本概念？特点？（认证、授权、加密、会话管理、与Web集成、缓存）
- 外部架构？（Subject、SecurityManager、Realm）
- 内部架构（了解每个组件功能，以及每个功能的大概实现流程）？（Subject、SecurityManager、Realm、Authenticator、Authrizer、SessionManager、SessionDAO、CacheManager、Cryptography）
- 身份认证过程？
- 授权过程？

答案往上找 -_-!!

### 3.1 Shiro 基本功能

Shiro可以帮助我们完成：**认证、授权、加密、会话管理、与Web集成、缓存**等。这不就是我们想要的嘛，而且Shiro的API也是非常简单；其基本功能点如下图所示：

![img](http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png)

- **Authentication**：身份认证/登录，验证用户是不是拥有相应的身份；

- **Authorization**：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；

- **Session Manager**：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；

- **Cryptography**：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；

- **Web Support**：Web支持，可以非常容易的集成到Web环境；

- **Caching**：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；

- **Concurrency**：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；

- **Testing**：提供测试支持；

- **Run As**：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；

- **Remember Me**：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。

### 3.2 Shiro 的内外架构

接下来我们分别从外部和内部来看看Shiro的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的API，且API契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。

#### 3.2.1 Shiro的外部架构

 首先，我们从外部来看Shiro吧，即从应用程序角度的来观察如何使用Shiro完成工作。如下图：

![img](http://dl2.iteye.com/upload/attachment/0093/9790/5e0e9b41-0cca-367f-8c87-a8398910e7a6.png) 

可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；其每个API的含义：

- **Subject**：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；

- **SecurityManager：**安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你**可以把它看成DispatcherServlet前端控制器**；

- **Realm：**域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即**安全数据源（提供用户的角色和权限信息）**。

##### 3.2.1.1 最简单的Shiro应用

 也就是说对于我们而言，最简单的一个Shiro应用：

1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；

2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。

**从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。**

#### 3.2.2 Shiro内部结构

接下来我们来从Shiro内部来看下Shiro的架构，如下图所示：

![img](http://dl2.iteye.com/upload/attachment/0093/9792/9b959a65-799d-396e-b5f5-b4fcfe88f53c.png)


- **Subject：**主体，可以看到主体可以是任何可以与应用交互的“用户”；

- **SecurityManager：**相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。

- **Authenticator：**认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；

- **Authrizer：**授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；

- **Realm：**可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；

- **SessionManager：**如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；

- **SessionDAO：**DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；

- **CacheManager：**缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能

- **Cryptography：**密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。

 ### 3.3 身份认证

**身份验证**，即在应用中谁能证明他就是他本人。一般提供如他们的身份ID一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。

在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份：

**principals**：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号。

**credentials**：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。

最常见的principals和credentials组合就是用户名/密码了。

#### 3.3.1 身份认证流程

![img](http://dl2.iteye.com/upload/attachment/0094/0173/8d639160-cd3e-3b9c-8dd6-c7f9221827a5.png)

流程如下：

1、首先调用Subject.login(token（通过principals和credentials组合得到，一般为用户名/密码）)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；

2、SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；

3、Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；

4、Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；

5、Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。

**常见的异常包括：**

DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）

#### 3.3.2 Realm

Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。

shiro默认提供的Realm：

![img](http://dl2.iteye.com/upload/attachment/0094/0175/34062d4e-8ac5-378a-a9e2-4845f0828292.png)

Realm接口的定义有：

```java
public interface Realm {
    String getName();

    boolean supports(AuthenticationToken token);

    AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;
}
```



#### 3.3.3 Authenticator及AuthenticationStrategy

**Authenticator的职责是验证用户帐号**，是Shiro API中身份验证核心的入口点： 

Java代码  [![收藏代码](https://jinnianshilongnian.iteye.com/images/icon_star.png)](javascript:void())

1. **public** AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  
2. ​            **throws** AuthenticationException;   

如果验证成功，将返回AuthenticationInfo验证信息；此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。

 SecurityManager接口继承了Authenticator，另外还有一个ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现：

- **FirstSuccessfulStrategy**：只要有一个Realm验证成功即可，只返回第一个Realm身份验证成功的认证信息，其他的忽略；

- **AtLeastOneSuccessfulStrategy**：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，返回所有Realm身份验证成功的认证信息；

- **AllSuccessfulStrategy**：所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。

### 3.4 授权

授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。

#### 3.4.1 关键概念

- 主体（Subject），即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。
- 资源（Resource），用户可以访问的任何东西，比如JSP页面、访问某个业务方法、打印文本等
- 权限（Permission）,用户有没有操作某个资源的权力（由三部分组成：用户+资源+操作）
- 角色（Role），角色代表了操作集合，可以理解为权限的集合，方便权利的分发。
  - 隐式角色：直接通过角色来验证用户有没有操作权限，粒度较粗，可能需要修改代码
  - 显示角色：在程序中通过权限控制谁能访问某个资源，即角色只是组合了一堆权限，不作为校验的粒度每次直击具体资源，粒度较细。

#### 3.4.2 授权方式

Shiro支持三种方式的授权：

- 编程式：通过写if/else授权代码块完成： 

```java
Subject subject = SecurityUtils.getSubject();  
if(subject.hasRole(“admin”)) {  
    //有权限  
} else {  
    //无权限  
}   
```



- 注解式：通过在执行的Java方法上放置相应的注解完成： 

```java
@RequiresRoles("admin")  
public void hello() {  
    //有权限  
}   
```

没有权限将抛出相应的异常；

- JSP/GSP标签：在JSP/GSP页面通过相应的标签完成： 

```xml
<shiro:hasRole name="admin">  
<!— 有权限 —>  
</shiro:hasRole>  
```

#### 3.4.3 Permission

规则：“资源标识符：操作：对象实例ID”  即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“:”表示资源/操作/实例的分割；“,”表示操作的分割；“*”表示任意资源/操作/实例。资源可以分等级实现，例如这种system:user。

权限类型：

- 单个资源单个权限，system:user:update
- 单个资源多个权限，system:user:update,delete
- 单个资源全部权限，system:user:create,update,delete,view
- 所有资源全部权限，*:view
- 实例级别权限
  - 单个实例单个权限，user:view:1  
  - 单个实例多个权限，user:view,update:1
  - 单个实例所有权限，user:*:1
  - 所有实例单个权限，user:view:*
  - 所有实例所有权限，user:\*:\*

#### 3.4.4 授权流程

![img](http://dl2.iteye.com/upload/attachment/0094/0549/541e4da3-d1a5-3d13-83a6-b65c3596ee4e.png)

流程如下：

1、首先调用Subject.isPermitted*/hasRole*接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；

2、Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；

3、在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；

4、Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted*/hasRole*会返回true，否则返回false表示授权失败。

#### 3.4.5 Authorizer、PermissionResolver及RolePermissionResolver
- Authorizer的职责是进行授权（访问控制），是Shiro API中授权核心的入口点，其提供了相应的角色/权限判断接口，具体请参考其Javadoc。SecurityManager继承了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。

- PermissionResolver用于解析权限字符串到Permission实例，
- RolePermissionResolver用于根据角色解析相应的权限集合。

### 3.5 Ini 配置

#### 3.5.1 配置的基本写法

1、对象名=全限定类名  相对于调用public无参构造器创建对象

2、对象名.属性名=值    相当于调用setter方法设置常量值

3、对象名.属性名=$对象引用    相当于调用setter方法设置对象引用

 #### 3.5.2 配置的组成部分

- **[main]部分**，提供了对根对象securityManager及其依赖对象的配置。
  - **创建对象** , securityManager=org.apache.shiro.mgt.DefaultSecurityManager  
  - **常量值setter注入** , jdbcRealm.permissionsLookupEnabled=**true**  
  - **对象引用setter注入** , securityManager.authenticator=$authenticator   
  - **嵌套属性setter注入**, securityManager.authenticator.authenticationStrategy=$authenticationStrategy   
  - **byte数组setter注入** , authenticator.bytes=0x68656c6c6f   
  - **Array/Set/List setter注入** , authenticator.array=1,2,3  
  - **Map setter注入**, authenticator.array=1:2  
  - **实例化/注入顺序**, 后边注入覆盖前面注入
- **[users]部分**，配置用户名/密码及其角色，格式：“用户名=密码，角色1，角色2”，角色部分可省略。
- **[roles]部分**，配置角色及权限之间的关系，格式：“角色=权限1，权限2
- **[urls]部分**，配置url及相应的拦截器之间的关系，格式：“url=拦截器[参数]，拦截器[参数]

### 3.6 Realm

#### 3.6.1 Realm

![img](https://s2.ax1x.com/2019/03/14/AA5wM8.png)

![img](http://dl2.iteye.com/upload/attachment/0094/1329/dd9f6a00-f6bc-3563-8afd-0c11048060b8.png)

基于上图所示的实体关系，得到五个数据库表实体：

- 用户实体包括：编号(id)、用户名(username)、密码(password)、盐(salt)、是否锁定(locked)；是否锁定用于封禁用户使用，其实最好使用Enum字段存储，可以实现更复杂的用户状态实现。

- 角色实体包括：、编号(id)、角色标识符（role）、描述（description）、是否可用（available）；其中角色标识符用于在程序中进行隐式角色判断的，描述用于以后再前台界面显示的、是否可用表示角色当前是否激活。

- 权限实体包括：编号（id）、权限标识符（permission）、描述（description）、是否可用（available）；含义和角色实体类似不再阐述。

- 用户-角色实体（用户编号、角色编号，且组合为复合主键）；
- 角色-权限实体（角色编号、权限编号，且组合为复合主键）。

#### 3.6.2 AuthenticationToken

![img](http://dl2.iteye.com/upload/attachment/0094/1333/6c026012-2583-3a26-af70-bb1b0eae491b.png)

- AuthenticationToken用于收集用户提交的身份（如用户名）及凭据（如密码）
- RememberMeAuthenticationToken：提供了“boolean isRememberMe()”现“记住我”的功能；
- HostAuthenticationToken：提供了“String getHost()”方法用于获取用户“主机”的功能。
- 直接拿来用的UsernamePasswordToken，用于实现用户名/密码Token组

#### 3.6.3 AuthenticationInfo

![img](http://dl2.iteye.com/upload/attachment/0094/1337/0be597af-cd61-34ce-b1f0-8ebd15dbdeb9.png)

AuthenticationInfo有两个作用：

1、如果Realm是AuthenticatingRealm子类，则提供给AuthenticatingRealm内部使用的CredentialsMatcher进行凭据验证；（如果没有继承它需要在自己的Realm中自己实现验证）；

2、提供给SecurityManager来创建Subject（提供身份信息）；

其他几个：

- MergableAuthenticationInfo用于提供在多Realm时合并AuthenticationInfo的功能，主要合并Principal、如果是其他的如credentialsSalt，会用后边的信息覆盖前边的。
- Account相当于我们之前的User，SimpleAccount是其一个实现
- 比如HashedCredentialsMatcher，在验证时会判断AuthenticationInfo是否是SaltedAuthenticationInfo子类，来获取盐信息
- **其他的情况，直接返回SimpleAuthenticationInfo**

#### 3.6.4 PrincipalCollection

因为我们可以在Shiro中同时配置多个Realm，所以呢身份信息可能就有多个；因此其提供了PrincipalCollection用于聚合这些身份信息

![img](http://dl2.iteye.com/upload/attachment/0094/1341/772c988b-e930-31d1-ad14-c9ae8f476f66.png)

#### 3.6.5 AuthorizationInfo

当我们使用AuthorizingRealm时，如果身份验证成功，在进行授权时就通过doGetAuthorizationInfo方法获取角色/权限信息用于授权验证。Shiro实现了一个SimpleAuthorizationInfo ，一般情况使用其就行。

![img](http://dl2.iteye.com/upload/attachment/0094/1345/c8868cea-6b01-34cc-b7be-45ee244bd217.png)

对于Account及SimpleAccount，之前的【6.3 AuthenticationInfo】已经介绍过了，用于SimpleAccountRealm子类，实现动态角色/权限维护的

#### 3.6.6 Subject

![img](http://dl2.iteye.com/upload/attachment/0094/1347/131b0c95-9aed-36b0-9c09-0a6f9c6b3605.png)

Subject是Shiro的核心对象，基本所有身份验证、授权都是通过Subject完成。

对于Subject我们一般这么使用：

**1、身份验证（login）**

**2、授权（hasRole\*/isPermitted\*或checkRole\*/checkPermission\*）**

**3、将相应的数据存储到会话（Session）**

**4、切换身份（RunAs）/多线程身份传播**

**5、退出**

### 3.7 拦截器机制

#### 3.7.1 基本介绍

![img](http://dl2.iteye.com/upload/attachment/0094/3897/b910abb9-2ef0-33b7-af4d-4c645263ed54.png)

- NameableFilter, 就是为了起个名字
- OncePerRequestFilter，一次请求只会走一次拦截器链
- ShiroFilter，整个Shiro的入口，用于拦截需要安全控制的请求进行处理
- AdviceFilter，提供AOP风格支持，包括preHandle、postHandle、afterCompletion三种增强
- PathMatchingFilter，包括pathsMatch用于path与请求路径进行匹配的方法，onpreHandle方法当匹配上一个路径后会调用其将路径绑定参数配置传给mappedValue
- AccessControlFilter，isAccessAllowed：表示是否允许访问；onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可。

#### 3.7.2 拦截器链

Shiro对Servlet容器的FilterChain进行了代理，在继续执行Servlet容器的Filter链之前，通过ProxiedFilterChian对Servlet容器的FilterChain进行了代理，即先走自己的Filter体系，然后才会委托给Servlet容器的FilterChain进行Servlet容器级别的Filter链执行。

### 3.8 缓存机制

Shiro提供了类似于Spring的Cache抽象，即Shiro本身不实现Cache，但是对Cache进行了又抽象，方便更换不同的底层Cache实现。

三个重要的接口：

```java
public interface Cache<K, V> {  
    //根据Key获取缓存中的值  
    public V get(K key) throws CacheException;  
    //往缓存中放入key-value，返回缓存中之前的值  
    public V put(K key, V value) throws CacheException;   
    //移除缓存中key对应的值，返回该值  
    public V remove(K key) throws CacheException;  
    //清空整个缓存  
    public void clear() throws CacheException;  
    //返回缓存大小  
    public int size();  
    //获取缓存中所有的key  
    public Set<K> keys();  
    //获取缓存中所有的value  
    public Collection<V> values();  
}  

public interface CacheManager {  
    //根据缓存名字获取一个Cache  
    public <K, V> Cache<K, V> getCache(String name) throws CacheException;  
}  

public interface CacheManagerAware {  
    //注入CacheManager  
    void setCacheManager(CacheManager cacheManager);  
}  
```

Shiro内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如Realm）是否实现了CacheManagerAware并自动注入相应的CacheManager。

#### 3.8.1 Realm缓存

Shiro提供了CachingRealm，其实现了CacheManagerAware接口，提供了缓存的一些基础实现；另外AuthenticatingRealm及AuthorizingRealm分别提供了对AuthenticationInfo 和AuthorizationInfo信息的缓存。

```ini
userRealm=com.github.zhangkaitao.shiro.chapter11.realm.UserRealm  
userRealm.credentialsMatcher=$credentialsMatcher  
userRealm.cachingEnabled=true  
userRealm.authenticationCachingEnabled=true  
userRealm.authenticationCacheName=authenticationCache  
userRealm.authorizationCachingEnabled=true  
userRealm.authorizationCacheName=authorizationCache  
securityManager.realms=$userRealm  
  
cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager  
cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml  
securityManager.cacheManager=$cacheManager   
```

#### 3.8.2 Session缓存

当我们设置了SecurityManager的CacheManager时，如：

```ini
securityManager.cacheManager=$cacheManager  
```

当我们设置SessionManager时：

```ini
sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager  
securityManager.sessionManager=$sessionManager   
```

如securityManager实现了SessionsSecurityManager，其会自动判断SessionManager是否实现了CacheManagerAware接口，如果实现了会把CacheManager设置给它。然后sessionManager会判断相应的sessionDAO（如继承自CachingSessionDAO）是否实现了CacheManagerAware，如果实现了会把CacheManager设置给它；如第九章的MySessionDAO就是带缓存的SessionDAO；其会先查缓存，如果找不到才查数据库。

### 3.9 会话管理

Shiro提供了完整的企业级会话管理功能，不依赖于底层容器（如web容器tomcat），不管JavaSE还是JavaEE环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对Web的透明支持、SSO单点登录的支持等特性。即直接使用Shiro的会话管理可以直接替换如Web容器的会话管理。

#### 3.9.1 会话

所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。

```java
login("classpath:shiro.ini", "zhang", "123");  
Subject subject = SecurityUtils.getSubject();  
Session session = subject.getSession();   
```

#### 3.9.2 会话管理器

会话管理器管理着应用中所有Subject的会话的创建、维护、删除、失效、验证等工作。是Shiro的核心组件，顶层组件SecurityManager直接继承了SessionManager，且提供了SessionsSecurityManager实现直接把会话管理委托给相应的SessionManager，DefaultSecurityManager及DefaultWebSecurityManager默认SecurityManager都继承了SessionsSecurityManager。

![img](http://dl2.iteye.com/upload/attachment/0094/6259/eb4cde34-53c1-3c46-abd5-0eda9de6400d.png)

Shiro提供了三个默认实现：

- **DefaultSessionManager**：DefaultSecurityManager使用的默认实现，用于JavaSE环境；

- **ServletContainerSessionManager**：DefaultWebSecurityManager使用的默认实现，用于Web环境，其直接使用Servlet容器的会话；

- **DefaultWebSessionManager**：用于Web环境的实现，可以替代ServletContainerSessionManager，自己维护着会话，直接废弃了Servlet容器的会话管理。

#### 3.9.3 会话监听器

会话监听器用于监听会话创建、过期及停止事件.

#### 3.9.4 会话存储/持久化 

Shiro提供SessionDAO用于会话的CRUD，即DAO（Data Access Object）模式实现.

![img](http://dl2.iteye.com/upload/attachment/0094/6261/6dac0cd6-f6ca-3e2d-b3ba-f8c7104e1b2a.png)

AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话ID等；CachingSessionDAO提供了对开发者透明的会话缓存的功能，只需要设置相应的CacheManager即可；MemorySessionDAO直接在内存中进行会话维护；而EnterpriseCacheSessionDAO提供了缓存功能的会话维护，默认情况下使用MapCache实现，内部使用ConcurrentHashMap保存缓存的会话。

#### 3.9.5会话验证

Shiro提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro提供了会话验证调度器`SessionValidationScheduler`来做这件事情。

#### 3.9.6 sessionFactory

sessionFactory是创建会话的工厂，根据相应的Subject上下文信息来创建会话；默认提供了SimpleSessionFactory用来创建SimpleSession会话。



## 4. 项目中关于权限管理系统可能涉及的问题（仅供参考）

### 4.1 简单介绍一下权限管理？

权限管理包括：控制用户访问某些功能、控制用户访问某些数据，即包括授权和鉴权。

- 权限管理的第一步为验证用户的身份+账号管理问题（禁用+停用）
- 权限 + 权限的认证（也有称为授权）
  - 功能权限：对象级功能（某块功能可用与否）、操作点权限（可操作性与否）、字段权限（展示与否）
  - 数据权限，代表数据私有、公开读、公开读写，以及数据的共享问题
- 角色 ，一类权限的组合，简化分配权限时的操作
- 常见的设计模式：RBAC（基于角色），ABAC（基于属性），DAC，MAC



**废话版：**权限管理是以用户为中心，控制用户访问某些功能或者数据，用户的身份标识通过账号进行体现（没有登录时或者游客模式等价于共享一个匿名账号），为了安全性账户有正常、禁用、停用等状态，禁用表示用户需要通过修改密码或者验证码等来再次确定用户的合法性（例如多次输入密码错误），而停用表示当前账户短时间内无法使用（例如离职）。用户具有的权限分为：功能权限和数据权限，功能权限为有整块功能的对象级功能权限，例如添加等操作点权限，以及展示与否的字段权限；数据权限表示数据是私有、公开读、公开写以及在某些用户内共享。可以直接通过验证用户具有的权限进行基于资源的权限管理（R（Resource）BAC），同时也可以通过将多个权限组合在一起形成角色，然后基于角色进行管理（R（Role）BAC）。

### 4.2 权限管理中常见的设计模式？

- RBAC（基于角色），用户关联角色，角色关联权限 + 隐式角色，显式角色 + 不同粒度 + 职责分离 + 对象权限控制
- ABAC（基于属性），用户+环境+操作+对象属性，集中化+不同粒度+无需预定义判断逻辑，权限不直观+设计维护麻烦+性能相对弱+太复杂而不常用
- DAC（自主访问控制），自行管理所属的权限 + 文件系统（例子）+权限松散，难管理，
- MAC（强访问控制），用户+资源双权限 + 严格商业系统
- ACL（Access Control List），控制权限列表

### 4.3 简单谈谈如何进行系统的设计？或者说你们是怎么做的？

- 设计模式：基于角色（隐式角色+显式橘色）

- 权限类型：功能权限 + 资源权限

- 用户管理：普通用户+管理员用户

- 框架：Shiro

- 框架原理：Subject（交互主体）、SecurityManager（安全管理器：交互中介+管理Subject+负责（认证+授权+会话+管理））、Realm（（可多个）权限数据源）

**串成话：**使用什么设计模式->分析系统功能和数据，得到权限类型->用户管理->所选用的框架->框架大概原理

### 4.4  谈谈你了解的权限管理框架？你了解Shiro吗？

- 功能：认证、授权、加密、会话管理、与Web集成、缓存，基于角色+基于资源）
- Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。
- 三大常用组件：Subject（交互主体）、SecurityManager（安全管理器：交互中介+管理Subject+负责（认证+授权+会话+管理））、Realm（（可多个）权限数据源）
- 身份认证（或授权）过程：Subject.login(.isPermitted/hasRole) -> SecurityManager Manager[Authenticator(Authorizer) -> Realm]

> 解释：这一条中括号代表另外一个流程。

- 认证异常：禁用+锁定+错误+登录失败次数超限+错误凭证+过期凭证

- 隐式角色（hasRole + 粗粒度+ 可能需要修改代码）+  显示角色（isPermitted + 细粒度 + 相对繁琐）
- 会话管理：不依赖容器（java SE+EE都可用）+  DefaultSessionManager(适用SE) + ServletContainerSessionManager（web，利用Servlet容器实现） +  DefaultWebSessionManager（web，自维护）
- 拦截器机制（web环境）：代理Servlet容器FIlterChain（先走自己，再委托Servlet容器）

### 4.5 权限验证的流程？RBAC权限管理流程？如何实现简单的RBAC？

- 答案一：仿照Shiro原理进行实现

- 答案二：

![img](https://img-blog.csdn.net/20180926111505509?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDA0NjE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 声明一个基类负责校验，所有类都要继承。
- 当用户进行访问时，判断用户状态是否为启用（一般会设置管理员是否启用/禁用）。
- 利用用户的账号+密码进行身份校验，校验成功进入下一步。
- 通过用户id查询user_role表里的角色id,并通过角色id查询role角色表状态为启用的角色id（可能是多个角色id）。
- 通过角色id查询role_access表里的全限id，并且通过全限id查询access表的权限(json格式，转换成数组)。
- 判断访问路由是否存在权限数组里。

### 4.7 Shiro关键词

- 外部架构中（Subject、SecurityManager、Realm）
- 内部架构中（Subject、SecurityManager、Realm、Authenticator、Authrizer、SessionManager、SessionDAO、CacheManager、Cryptography）
- AuthenticationInfo（用户的角色信息集合）
- AuthorizationInfo（角色的权限信息集合）

## 5. 项目中其他可能会问的问题

### 5.1 项目中做了什么？

（文档管理子系统 + 权限管理子系统 + 审计子系统）设计

### 5.2 文档管理子系统怎么做的？

关键技术：

传输（分段传输+文件正确性校验+安全性+传输任务管理）

存储（存储方式+目录管理+版本控制+备份）

使用（查询+预览）

**特别说明：**每个小点都是大坑，每个里面都可以问很详细的问题，但是一来没做，都是瞎吹，二来时间来不及好好研究。

#### 5.2.1 各部分解释

**分段传输**：对于过大的文件需要将其拆分成为小的文件进行传输，但是这个过程对于用户来说是透明的。

**文件正确性校验**：为了防止文件在传输的过程中被篡改，在发送文件之前对文件生成MD5校验码，发送到服务器端，在服务器端生成MD5校验值并和客户端发送过来的校验值进行对比，如果不一致拒绝接受文件。下载时也是同样的处理，同时传输文件和校验码，然后利用生成的校验码和传输的校验码比较文件是否发生了改变，如果发生了改变则拒绝文件。

**安全性：**为了保证数据的安全性，在传输数据之前可以对数据进行加密操作；此外安全性还体现在用户的身份上，能够使用系统的用户需要进行严格的身份认证以及权限控制，避免非法用户以及非法访问

**传输任务管理：**支持传输任务的暂停、开始、停止、重新开始等操作

**存储方式：**最基本的方式为直接利用服务器的文件系统进行存储，也设计了使用分布式的存储系统HDFS进行存储，但由于单个文件过小，需要对小文件进行归档（HAR，Hadoop归档文件，就是一堆文件组合在一起）存储。

**目录管理：**如果直接存在服务器文件系统中，那么目录管理就直接使用系统的就完事了。否则的话仿照Linux文件系统进行，妈呀，也不会。

**版本控制：**采用线性版本控制策略（想象一下链表）

**备份：**自动备份（定时备份）+手动备份

**查询：** 支持基于关键字的查询，最基本的方式为将所有的文件名以及文件夹名字段建立索引，查询时在索引中查询。

**预览：**显示图片，使用Viewer.js 实现PDF/Office的在线预览。

### 5.3 权限管理子系统怎么做的？

- 设计模式：基于角色（隐式角色+显式橘色）
- 权限类型：功能权限 + 资源权限
- 用户管理：普通用户+管理员用户
- 框架：Shiro
- 框架原理：Subject（交互主体）、SecurityManager（安全管理器：交互中介+管理Subject+负责（认证+授权+会话+管理））、Realm（（可多个）权限数据源）

**串成话：**使用什么设计模式->分析系统功能和数据，得到权限类型->用户管理->所选用的框架->框架大概原理

### 5.4 审计子系统怎么做的？

如何实现：

- 数据库审计：数据库层面自带的审计，在数据库操作发生时，捕捉并记录与操作相关的时间、对象和行为
- 功能审计：在权限管理子系统的基础上进行增强，在每次权限校验时根据规则记录Who+When+How+What（谁在什么时间怎么操作了什么对象）。-
- 审计日志定时转储

### 5.5 你认为最具有挑战的是哪部分？简单说一说？

权限管理部分，内容见上面所有，感觉可以谈论对权限管理的认识。



![夸夸你](https://s2.ax1x.com/2019/03/15/AViel6.png)

## 参考文献

- [权限系统设计模型分析（DAC，MAC，RBAC，ABAC）](https://www.jianshu.com/p/ce0944b4a903)
- [ABAC基于属性的访问控制](https://blog.csdn.net/blog_empire/article/details/81867433)
- [教你建立后台通用权限管理系统](http://www.chanpin100.com/article/107449)
- [关于产品权限管理系统](https://www.jianshu.com/p/36dbe0e190c8)
- [如何设计网站权限系统](https://www.zhihu.com/question/20313385)
- [Shiro入门这篇就够了【Shiro的基础知识、回顾URL拦截】](https://segmentfault.com/a/1190000013875092)
- [30分钟学会Shiro](http://www.cnblogs.com/learnhow/p/5694876.html)
- [第一章  Shiro简介——《跟我学Shiro》](https://jinnianshilongnian.iteye.com/blog/2018936)
- [《跟我学Shiro》PDF完结版下载](https://jinnianshilongnian.iteye.com/blog/2049092)
- [权限系统与RBAC模型概述[绝对经典]](https://blog.csdn.net/yangwenxue_admin/article/details/73936803)
- [访问控制模型DAC，MAC，RBAC](https://blog.csdn.net/wangkaiblog/article/details/40745781)
- [DBAC权限管理](https://blog.csdn.net/m0_38004619/article/details/82850601)
- [Spring AOP详细介绍](https://www.cnblogs.com/liuruowang/p/5711563.html)
- [轻松理解AOP思想(面向切面编程)](https://www.cnblogs.com/Wolfmanlq/p/6036019.html)
- [java动态代理实现与原理详细分析](https://www.cnblogs.com/gonjan-blog/p/6685611.html)
- [java的动态代理机制详解](https://www.cnblogs.com/xiaoluo501395377/p/3383130.html)
- [Java动态代理之JDK实现和CGlib实现（简单易懂）](https://www.cnblogs.com/ygj0930/p/6542259.html)
- [cglib实现动态代理构建带参数的代理实例](https://my.oschina.net/u/1866821/blog/364773)
- [Spring AOP 实现功能权限校验功能](https://www.cnblogs.com/yhtboke/p/5749063.html)
- [权限管理中基于角色的访问控制与基于资源的访问控制](https://blog.csdn.net/liangwanmian/article/details/79127342)
- [基于资源的权限系统-设计思路](https://www.cnblogs.com/wang_yb/p/6117468.html)

