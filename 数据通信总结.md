# 数据通信总结

## 1. 常见RPC框架

**RPC采用客户端（服务调用方）/服务器端（服务提供方）模式**，主要依赖的技术包括序列化和反序列化和数据的传输协议，是一种实现与定义相分离的设计方式。

- **RMI（JDK自带）：** JDK自带的RPC

  详细内容可以参考：[从懵逼到恍然大悟之Java中RMI的使用](https://blog.csdn.net/lmy86263/article/details/72594760)

- **Dubbo:** Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。

  详细内容可以参考：

  - [高性能优秀的服务框架-dubbo介绍](https://blog.csdn.net/qq_34337272/article/details/79862899)
  - [Dubbo是什么？能做什么？](https://blog.csdn.net/houshaolin/article/details/76408399)

- **Hessian：** Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。

  详细内容可以参考： [Hessian的使用以及理解](https://blog.csdn.net/sunwei_pyw/article/details/74002351)

- **Thrift：** Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。

  详细内容可以参考： [【Java】分布式RPC通信框架Apache Thrift 使用总结](https://www.cnblogs.com/zeze/p/8628585.html)

如何选择框架：

- **是否允许代码侵入：** 即需要依赖相应的代码生成器生成代码，比如Thrift。
- **是否需要长连接获取高性能：** 如果对于性能需求较高的haul，那么可以果断选择基于TCP的Thrift、Dubbo。
- **是否需要跨越网段、跨越防火墙：** 这种情况一般选择基于HTTP协议的Hessian和Thrift的HTTP Transport。

### 1.1 RMI

Java RMI用于不同的虚拟机之间进行通信，其具有的特点是：

- 优点：避免重复造轮子
- 缺点：调用过程缓慢，调用过程不可靠，如发生网络错误

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170521103734214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG15ODYyNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

从逻辑上看，数据在server和client之间横向流动，实际上是先纵向移动，然后再横向移动。

#### 1.1.1 重要问题

##### 1.1.1.1 数据传递问题

-  将引用改为值传递，也就是将对象序列化为字节，然后使用该字节副本进行传递，数据**不共享**,对象可以被序列化的条件：
  - 是基本数据类型
  - 实现了java.io.Serializable接口
  - 对于容器类，如果对象是可以序列化的，那么该容器也可以序列化
  - 可序列化的子类也可以序列化
- 任然使用引用传递，远程主机调用本地主机方法时，同时通过本地方法查询该引用对应的对象，数据是**共享**的

**RMI中参数传递和结果返回的三种方式：**

- 简单类型：按值传递，直接传递数据拷贝；
- 远程对象引用（实现了`Remote`接口）：以远程对象的引用传递；
- 远程对象引用（未实现`Remote`接口）：按值传递，通过序列化对象传递副本，本身不允许序列化的对象不允许传递给远程方法；

##### 1.1.1.2 远程对象的发现问题

其规范如下所示：

- 该名称是URL形式的，类似于http的URL，schema是rmi；
- 格式类似于rmi://host:port/name，host指明注册表运行的注解，port表明接收调用的端口，name是一个标识该对象的简单名称。
- 主机和端口都是可选的，如果省略主机，则默认运行在本地；如果端口也省略，则默认端口是1099；
#### 1.1.2 编程实现

看看热闹！具体见博客[从懵逼到恍然大悟之java中RMI的使用](https://blog.csdn.net/lmy86263/article/details/72594760)

### 1.2 Dubbo

> Dubbo是 阿里巴巴公司开源的一个**高性能优秀的服务框架**，使得应用可通过高性能的 **RPC** 实现服务的输出和输入功能，可以和 Spring框架无缝集成。

**说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）**

**核心**部分包括：

1. 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
2. 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
3. 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

**功能：**

1. 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。      
2. 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。

3. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。

#### 1.2.1 架构

![dubboæ¶æ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-4-9/95449759.jpg)

**节点的简单说明**

- **Provider** 暴露服务的服务提供方
- **Consumer** 调用远程服务的服务消费方
- **Registry** 服务注册与发现的注册中心
- **Monitor** 统计服务的调用次数和调用时间的监控中心
- **Container** 服务运行容器

**调用关系说明**

1. **服务容器**负责启动，加载，运行服务提供者。 
2. **服务提供者**在启动时，向注册中心注册自己提供的服务。 
3. **服务消费者**在启动时，向注册中心订阅自己所需的服务。 
4. **注册中心**返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 
5. **服务消费者**，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 
6. **服务消费者和提供者**，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到**监控中心**。
#### 1.2.2 注册中心

一个完整的dubbo应该是包括注册中心的。 
注册中心用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是IP地址和服务名称的对应关系。 
dubbo官方提供了几种**实现注册中心的方式： **

1. Multicast 注册中心 
2. Zookeeper 注册中心（推荐使用） 
3. Redis 注册中心 
4. Simple 注册中心
#### 1.2.3 使用

[Dubbo用户手册(中文)](https://github.com/apache/incubator-dubbo)

### 1.3 Hessian

Hessian是一个轻量级的RPC框架,它基于HTTP协议传输，使用**Hessian二进制序列化**，对于数据包比较大的情况比较友好。参数和返回值都需要实现序列化接口。Spring同样对其有很好的支持，通过使用spring-remoting包可以很方便地发布和调用服务。

基于tomcat实现，服务通过servlet进行绑定，请求和结果都是通过序列化后就直接通过http服务进行传输。

### 1.4 Thrift

Apache Thrift是FaceBook开源的跨语言的RPC通信框架。Thrift实际上是C/S模式。

服务器端需要发布一个服务给别人使用，首先要约定好服务的接口。包括以下的几个部分：

- 服务的名称
- 服务使用时的参数
- 返回结果

使用自己规定了一套接口语言（IDL）来描述服务，后缀为.thrift文件来描述。这个接口可以利用提供的程序来将当前的thrift文件转化为其他语言的接口。

![img](https://images0.cnblogs.com/blog/603001/201501/141600556986345.jpg)

## 2. 消息中间件

**消息中间件，也可以叫做中央消息队列或者是消息队列（区别于本地消息队列，本地消息队列指的是JVM内的队列实现）**，是一种独立的队列系统，消息中间件经常用来解决内部服务之间的 **异步调用问题** 。请求服务方把请求队列放到队列中即可返回，然后等待服务提供方去队列中获取请求进行处理，之后通过回调等机制把结果返回给请求服务方。

异步调用只是消息中间件一个非常常见的应用场景。此外，常用的消息队列应用场景还有如下几个：

- **解耦 ：** 一个业务的非核心流程需要依赖其他系统，但结果并不重要，有通知即可。分布式部署以后的聚合方式通常有两种，**分布式消息队列**和**分布式服务**
- **最终一致性 ：** 指的是两个系统的状态保持一致，可以有一定的延迟，只要最终达到一致性即可。经常用在解决分布式事务上。
- **广播 ：** 消息队列最基本的功能。生产者只负责生产消息，订阅者接收消息。
- **错峰和流控**：**通过异步处理提高系统性能**

![éè¿å¼æ­¥å¤çæé"ç³"ç"æ§è½](https://user-gold-cdn.xitu.io/2018/4/21/162e63a8e34ba534?w=910&h=350&f=jpeg&s=29123)

在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善

[《消息队列深入解析》](https://blog.csdn.net/qq_34337272/article/details/80029918)

当前使用较多的消息队列有ActiveMQ（性能差，不推荐使用）、RabbitMQ、RocketMQ、Kafka等等，我们之前提到的redis数据库也可以实现消息队列，不过不推荐，redis本身设计就不是用来做消息队列的。

![img](https://user-gold-cdn.xitu.io/2018/4/21/162e815225ecc0c8?w=905&h=426&f=jpeg&s=57671)

### 2.1 ActiveMQ

ActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE 1.4规范的JMSProvider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。

具体可以参考：

[《消息队列ActiveMQ的使用详解》](https://blog.csdn.net/qq_34337272/article/details/80031702)

**特点：**

1. 支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议
2. 完全支持JMS客户端和Message Broker中的企业集成模式
3. 支持许多高级功能，如消息组，虚拟目标，通配符和复合目标
4. 完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息
5. Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置
6. 专为高性能集群，客户端 - 服务器，基于对等的通信而设计
7. CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递
8. 可以用作内存JMS提供程序，非常适合单元测试JMS
9. 支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输
10. 使用JDBC和高性能日志支持非常快速的持久性

#### 2.1.1 JMS

**JMS**： java 消息服务，是java EE平台上的一个消息服务的标准或说是规范。

**五种消息正文格式：**

- StreamMessage – Java原始值的数据流
- MapMessage–一套名称-值对
- TextMessage–一个字符串对象
- ObjectMessage–一个序列化的 Java对象
- BytesMessage–一个字节的数据流

**两种消息模型**

1. 点到点（p2p）模型

![ç¹å°ç¹ï¼P2Pï¼æ¨¡å](https://user-gold-cdn.xitu.io/2018/4/21/162e7185572ca37d?w=575&h=135&f=gif&s=8530)

使用队列作为消息通信载体，满足生产者与消费者模式。

2. 发布/订阅（Pub/Sub）模型

![åå¸/è®¢éï¼Pub/Subï¼æ¨¡å](https://user-gold-cdn.xitu.io/2018/4/21/162e7187c268eaa5?w=402&h=164&f=gif&s=15492)

**主题（Topic）作为消息通信载体，类似于广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，**在一条消息广播之后才订阅的用户则是收不到该条消息的**。

### 2.2 RabbitMQ

**RabbitMQ:** RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗

> AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。

具体可以参考：

[《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57)

**特点： **

1. 异步消息传递：支持多种消息协议，消息队列，传送确认，灵活的路由到队列，多种交换类型； 
2. 支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等； 
3. 可以部署为高可用性和吞吐量的集群; 跨多个可用区域和区域进行联合； 
4. 可插入的身份验证，授权，支持TLS和LDAP。； 
5. 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面； 
6. 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件.

![img](https://upload-images.jianshu.io/upload_images/5015984-367dd717d89ae5db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp)

里面的具体概念见上面提及的博客，主要说明几个概念：

- Binding：就是交换机和队列的绑定路由表
- Virtual Host：vhost其实就是一个mini版的RabbitMq服务
- Broker：表示消息队列服务器实体
- Channel：多路复用连接中的一条独立的双向数据流通道

#### 2.2.1 消息路由

![img](https://upload-images.jianshu.io/upload_images/5015984-7fd73af768f28704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/484/format/webp)

和jms不同的是，生产者把消息发送到Exchange上，Binding决定交换器的消息应该发送到那个队列。Exchange分发消息时常用的三种策略类型：

- direct：是完全匹配、单播模式
- fanout：不处理路由键，只简单地将队列绑定到交换器上，之后的消息会被发送到所有与交换器绑定的所有的队列上，类似于子网广播，是最快的方式。
- topic：通过模式匹配分配消息的路由键属性，支持#和\* 通配符，前者匹配0个或者多个单词，后者匹配一个单词

#### 2.2.2 RabbitMQ集群

RabbitMQ 最优秀的功能之一就是内建集群，这个功能设计的目的是允许消费者和生产者在节点崩溃的情况下继续运行，以及通过添加更多的节点来线性扩展消息通信吞吐量。RabbitMQ 内部利用 Erlang 提供的分布式通信框架 OTP 来满足上述需求，使客户端在失去一个 RabbitMQ 节点连接的情况下，还是能够重新连接到集群中的任何其他节点继续生产、消费消息。

RabbitMQ始终会记录以下四种类型的内部元数据：

1. 队列元数据
   包括队列名称和它们的属性，比如是否可持久化，是否自动删除
2. 交换器元数据
   交换器名称、类型、属性
3. 绑定元数据
   内部是一张表格记录如何将消息路由到队列
4. vhost 元数据
   为 vhost 内部的队列、交换器、绑定提供命名空间和安全属性

### 2.3 RocketMQ

具体可以参考：

[《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)

[《十分钟入门RocketMQ》](http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/) （阿里中间件团队博客）

RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。

特点： 

1. 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型 
2. 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递 
3. 支持拉（pull）和推（push）两种消息模式 
4. 单一队列百万消息的堆积能力 
5. 支持多种消息协议，如 JMS、MQTT 等 
6. 分布式高可用的部署架构,满足至少一次消息传递语义 
7. 提供 docker 镜像用于隔离测试和云集群部署 
8. 提供配置、指标和监控等功能丰富的 Dashboard

#### 2.3.1 **构架如下图所示：**

![img](https://upload-images.jianshu.io/upload_images/6332814-7885601f065a3556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/975/format/webp)

从上面可以看出由四个集群组成：

- NameServer，提供轻量级服务发现和路由
- Broker，通过提供轻量级的Topich和Queue机制来处理消息存储，同时支持推和拉的模式，以及主从结构快速存储拓展。
- Producer，生产者，产生消息的实例，相同的Producer Group的Producer组成一个集群
- Consumer，消费者，接受消息进行消费的实例。

Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。

#### 2.3.2 集群部署模式

- 单 master 模式
   也就是只有一个 master 节点，称不上是集群，一旦这个 master 节点宕机，那么整个服务就不可用，适合个人学习使用。
- 多 master 模式
   多个 master 节点组成集群，单个 master 节点宕机或者重启对应用没有影响。
   优点：所有模式中**性能最高**
   缺点：单个 master 节点宕机期间，未被消费的消息在节点恢复之前不可用，消息的实时性就受到影响。
   **注意**：使用同步刷盘可以保证消息不丢失，同时 Topic 相对应的 queue 应该分布在集群中各个节点，而不是只在某各节点上，否则，该节点宕机会对订阅该 topic 的应用造成影响。
- 多 master 多 slave 异步复制模式
   在多 master 模式的基础上，每个 master 节点都有至少一个对应的 slave。**master
   节点可读可写**，但是**slave 只能读不能写**，类似于 mysql 的主备模式。
   优点： 在 master 宕机时，消费者可以从 slave 读取消息，消息的实时性不会受影响，性能几乎和多 master 一样。
   缺点：使用异步复制的同步方式有可能会有**消息丢失的问题**。
- 多 master 多 slave 同步双写模式
   同多 master 多 slave 异步复制模式类似，区别在于 master 和 slave 之间的数据同步方式。
   优点：同步双写的同步模式**能保证数据不丢失**。
   缺点：发送单个消息**RT 会略长**，性能相比异步复制低10%左右。
   刷盘策略：同步刷盘和异步刷盘（指的是节点自身数据是同步还是异步存储）
   同步方式：同步双写和异步复制（指的一组 master 和 slave 之间数据的同步）
   **注意**：要保证数据可靠，需采用同步刷盘和同步双写的方式，但性能会较其他方式低。

### 2.4 Kafka

**Kafka**：Kafka是一个分布式的、可分区的、可复制的、基于发布/订阅的消息系统（现在官方的描述是“一个分布式流平台”）,Kafka主要用于大数据领域,当然在分布式系统中也有应用。目前市面上流行的消息队列RocketMQ就是阿里借鉴Kafka的原理、用Java开发而得。

具体可以参考：

[《Kafka应用场景》](http://book.51cto.com/art/201801/565244.htm)

[《初谈Kafka》](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484106&idx=1&sn=aa1999895d009d91eb3692a3e6429d18&chksm=fd9854abcaefddbd1101ca5dc2c7c783d7171320d6300d9b2d8e68b7ef8abd2b02ea03e03600#rd)

特点： 

1. 同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。 
2. 可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。 
3. 分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。 
4. 消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。 
5. 支持online和offline的场景。

#### 2.4.1 应用场景：

- 消息系统
- 应用监控
- 网站用户行为追踪
- 流处理
- 持久性日志

#### 2.4.2 基本概念

Kafka适合**离线和在线的消息**消费，而消息时保存在磁盘上。

- Broker, 一个单独的Kafka Server
- 消息，最基本的消息单元，由一串字节组成，其中主要有key和value构成，key的作用是根据一定的策略将这个消息路由到指定的分区中，这样保证相同的key对应的消息一定在相同分区里
- Topic，可以看做是一个消息的集合，可有多个producer和多个consumer和其交互
- 分区（partition），每一个Topic可以划分为多个分区，不同的分区分配在不同的Broker上，以对kafka进行水平拓展。分区的时候分配一个offset，它是分区中唯一编号，此外Kafka通过offset保证消息在分区中的顺序，offset分区的顺序不能跨分区（即同一个分区中有序，分区之间无序）。

![img](https://mmbiz.qpic.cn/mmbiz/hvUCbRic69sAXcuUpm3JxK4AWSETiava7eY5yL6GkiaHc3A1UoUBzArQxdgibrrwv5K6mWrB7aOFxXmOVUQBibQCI3g/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- Log，分区在逻辑上对应着一个Log，当生产者将消息写入分区的时候，实际上就是写入到一个Log中。
- 副本，对分区的冗余备份，类型分为：Leader和Follower，当只有一个副本的时候属于Leader，没有Follower。副本具有一定的同步机制，会在Follower中选择出一个Leader负责读写请求，其他的Follower从Leader中拉取数据。
- 生产者，产生消息，并按照一定的规则推送到Topic的分区中
- ISR，ISR集合表示的是目前可用(alive)且消息量与Leader相差不多的副本集合,即整个副本集合的子集。