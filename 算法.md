# 算法

## 1. 字符串算法题

### 1.1 KMP算法（最常用的字符串匹配算法）

#### 1.1.1 字符串比较的暴力法

按位比较两个字符串的是否相同，如果遇到不相同从上一个匹配位置的下一个位置继续进行比较。

**缺点：** 在主串上移动时每次只能移动一个位置，时间复杂度较高，最差情况下为O(nm)

#### 1.1.2 KMP 算法（简单版）

**原理：**充分利用之前的已经比较过的信息，已经比较过的位置尽可能不去比较，即在主串上不动，而在子串上进行移动。如果子串的位置不是从第一位开始，而是从某位开始的话，那么就比暴力方法会快好多了。

**算法过程：**

1. 首先计算部分匹配表（部分匹配表可以替换为移动位数表）：

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)

部分匹配表的计算比较简单，就是以当前位置截断字符串的前缀后缀重叠的字符数。例如"A",没有前后缀，填入0，“ABCD”前后缀中没有重复字符，填入0，“ABCDA”，有一个重叠的前后缀“A”，填入1，依照上面的规律可以快速填完这个表。

2. 进行匹配操作，如果在遇到不匹配字符之前子串已经匹配完成，返回匹配的结果，否则匹配直到遇到不匹配的字符，此时需要计算子串的移动位数。计算公式如下所示：

> 　**移动位数 = 已匹配的字符数 - 对应的部分匹配值**

**特别注意：上面的这个计算公式中说的位置是不匹配的上一个，即最后一个匹配**

3. 根据上一步计算得到的结果进行移位继续匹配，直到匹配完成或者遇到第一个不匹配的字符后继续进行第二步操作，直到结束。

**关于移位的理解：**首先部分匹配表中维护中子串中开始和结尾的重复情况，如果部分匹配表中数据为0那么，就是说明主串中当前已经匹配的部分的任何子部分都不可能和子串相匹配上，可以放心地跳过，如果前后缀具有重复的话那么利用和前缀重合的最长后缀当做新的已经匹配部分是没有问题的。

#### 1.1.3 KMP（升级版，不好理解版本，但是代码简洁）

上面一种方式中，需要经过多次计算得到当前子字符串上的移动位置，造成一定计算开销和导致结果代码变得复杂。于是通过一次计算得到j的下一个位置。

**next数组的由来：通过将部分匹配数组进行右移一位得到，这里为什么右移是由于之前说的计算是最后一个匹配位置的移动位置，所以需要对其进行一次移动**

![img](https://pic4.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_hd.jpg)

```java
//计算next数组
private void getNext(char[] p, int[] next){
	next[0] = -1;
	int i = 0, j = -1;

	while (i < p.length)
	{
		if (j == -1 || p[i] == p[j])
		{
			++i;
			++j;
			next[i] = j;
		}	
		else
			j = next[j];
	}
}
//Kmp算法实现
public int KMP(char[] t, char[] p) 
{
	int i = 0; 
	int j = 0;

	while (i < t.length && j < p.length)
	{
		if (j == -1 || t[i] == p[j]) 
		{
			i++;
           	j++;
		}
	 	else 
           	j = next[j];
    	}

    if (j == p.length)
       return i - j;
    else 
       return -1;
}

```

### 1.2 其他简单算法

#### 1.2.1 替换空格

没啥好说就是直接替换进行

#### 1.2.2 最长公共前缀

没啥好说的，从第一位开始每个字符串都比较，如果相同则后移一位，不同则返回之前结果。

#### 1.2.3 最长回文串

由一堆字母组成的最长回文串，使用成对匹配法进行处理，那么最长的回文串就是配对数数m乘以2，如果还有剩余的字符随便选一个将其放置于字符串的中间，构成的字符串依然是回文。所以最长的结果是2m或者2m+1.

#### 1.2.4 验证回文串

前后指针法，从前遍历的结果和从后遍历的结果应该一致。

#### 1.2.5 最长回文子串（子串连续）

```
输入: "babad"
输出: "bab"
注意: "aba"也是一个有效答案。
```

中间开花式，即默认某个字符是中心，然后向两边同时拓展验证。具体如下图所示：

![img](https://camo.githubusercontent.com/bb17670ba0c3dfd23f7ef2222bd6d6d2d80fd11e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f392f313635626333326636663138333366663f773d37323326683d33373126663d706e6726733d39333035)

#### 1.2.6 最长回文子序列（子串中元素不要求有序，但是要求保证相对顺序）

```
输入:
"bbbab"
输出:
4
```

采用动态规划实现：

``` 
 if s.charAt(i) == s.charAt(j):
 	dp[i][j] = dp[i+1][j-1]
 else:
 	dp[i][j] = Max(dp[i+1][j], dp[i][j-1])
```

#### 1.2.7  括号匹配深度

> 爱奇艺 2018 秋招 Java： 一个合法的括号匹配序列有以下定义:
>
> 1. 空串""是一个合法的括号匹配序列
> 2. 如果"X"和"Y"都是合法的括号匹配序列,"XY"也是一个合法的括号匹配序列
> 3. 如果"X"是一个合法的括号匹配序列,那么"(X)"也是一个合法的括号匹配序列
> 4. 每个合法的括号序列都可以由以上规则生成。

> 例如: "","()","()()","((()))"都是合法的括号序列 对于一个合法的括号序列我们又有以下定义它的深度:
>
> 1. 空串""的深度是0
> 2. 如果字符串"X"的深度是x,字符串"Y"的深度是y,那么字符串"XY"的深度为max(x,y)
> 3. 如果"X"的深度是x,那么字符串"(X)"的深度是x+1

> 例如: "()()()"的深度是1,"((()))"的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。

![img](https://camo.githubusercontent.com/0f2df24b3f311ffd821b8322a43042eecf45df40/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f392f313635626336666361393465663237383f773d37393226683d33323426663d706e6726733d3135383638)

#### 1.2.8 把字符串转换成为整数

正常的操作，首先解析符号位，其次解析的数字，如果遇到非数值则直接返回0，没解析一位数字，临时结果乘以10，代表处理下一位。

#### 1.2.8 把字符串转换成为小数

合法小数的结构如下所示：

```
有符号整数  [ 小数点 无符号整数 ] [E | e 有符号整数]
```

基于上面的分段分析，可以将验证过程可以变为：通过定位分隔符然后变为验证有符号整数或无符号整数。

## 2. 链表

### 2.1 两数相加

注意这是低位到高位存储，如果是高位到低位的话需要将链表转置后再加，如果要求链表不能动，最后需要把倒转的链表再倒转过来。

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

![å¾1ï¼å¯¹ä¸¤æ°ç¸å æ¹æ³çå¯è§å: 342 + 465 = 807342+465=807ï¼ æ¯ä¸ªç"ç¹é½åå"ä¸ä¸ªæ°å­ï¼å¹¶ä¸æ°å­æä½éåºå­å¨ã](https://camo.githubusercontent.com/db5e7cb12fcf61ee67677537d6a34fbb4a90d291/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32302f33343931303935362e6a7067)

### 2.2 反转链表

```java
public class Solution {

  public ListNode ReverseList(ListNode head) {

    ListNode next = null;
    ListNode pre = null;

    while (head != null) {
      // 保存要反转到头的那个节点
      next = head.next;
      // 要反转的那个节点指向已经反转的上一个节点(备注:第一次反转的时候会指向null)
      head.next = pre;
      // 上一个已经反转到头部的节点
      pre = head;
      // 一直向链表尾走
      head = next;
    }
    return pre;
  }

}
```

### 2.3  双指针法

#### 2.3.1 链表中倒数第k个节点

快指针先走k步，然后快慢两个指针一起走，当快指针为空时，满指针所指的节点就是倒数第看个节点。

#### 2.3.2 删除链表中倒数第k个节点

方法1：两次遍历，先计算链表长度，然后计算出前面应该跳过的节点个数。

方法2：首先找到链表中倒数第k+1个节点，然后将其后继直接指向后继的后继即可，但是需要注意判空（当删除倒数第一个节点时，以及只有一个节点等情况）

### 2.4 合并两个排序链表

首先选出开始元素较小的链，以其头作为头，之后摘数值小的节点连接到新链上。