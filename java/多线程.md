# java多线程并发

![java知识库](https://s2.ax1x.com/2019/03/23/AJMarj.png)

##  1. 多线程基础

### 1.1 Java线程实现/创建的方式

```java
package multithread;

import java.util.concurrent.*;

class Thread1 implements Runnable {
    public void run() {
        // coding here
        System.out.println("Thread 1 name: " + Thread.currentThread().getName());
    }
}

class Thread2 extends Thread {
    public void run() {
        // coding here
        System.out.println("Thread 2 name: " + Thread.currentThread().getName());
    }
}

class Thread3 implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        // coding here
        System.out.println("Thread 3 name: " + Thread.currentThread().getName());
        return 1;
    }
}

public class StartThread {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //way1，实现Runnable接口
        new Thread(new Thread1()).start();
        //way2，基础自Thread类
        new Thread2().start();
        //way3，实现Callable接口+利用线程池
        ExecutorService pool = Executors.newSingleThreadExecutor();
        Future futureTask = pool.submit(new Thread3());
        System.out.println("Result from thread 3: " + futureTask.get());
        //way4，直接使用线程池
        pool.submit(new Runnable() {
            @Override
            public void run() {
                //coding here
                System.out.println("Thread 4 name: " + Thread.currentThread().getName());
            }
        });

        pool.shutdown();
    }
}
```

### 1.2 四种线程池

> - newCachedThreadPool：如果当前没有可用线程则新创建，如果存在可用就重用之前的线程，对于长时间没有使用的线程移出线程池**，可用就重用，不可用就新建，回收长时间不使用**
>
> - newFixedThreadPool：**固定数量的可重用线程池，以共享无界队列方式来运行这些线程**，如果任务失败可以使用另外的线程来代替其执行，线程存在到被显示关闭
>
> - newScheduledThreadPool：**固定线程数量线程池，可以指定延迟后执行或周期执行**
>
>   ```java
>   ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);
>   scheduledThreadPool.schedule(newRunnable(){
>   	 @Override
>   	 public void run() {
>   		 System.out.println("延迟三秒");
>    	}
>    }, 3, TimeUnit.SECONDS);
>   scheduledThreadPool.scheduleAtFixedRate(newRunnable(){
>    	@Override
>    	public void run() {
>    		System.out.println("延迟 1 秒后每三秒执行一次");
>    	}
>    },1,3,TimeUnit.SECONDS);
>   ```
>
> - newSingleThreadExecutor：只有一个线程的线程池，不同单个线程的是**如果线程死掉，会重新创建一个线程来代替原来的线程继续执行下去，而不使用线程池的方式中线程死了就结束了**

![](https://s2.ax1x.com/2019/03/23/AJ1lZ9.png)

### 1.3 线程生命周期（状态）

![img](https://images2015.cnblogs.com/blog/716271/201703/716271-20170320112245721-1831918220.jpg)

- **新建状态（new）**，对象被创建后进入，调用start之前
- **就绪状态（Runnable）**，可执行状态，现在只缺计算计算资源，也是获取CPU前置状态
- **运行状态（Running）**，获取CPU权限进行执行
- **阻塞状态（Blocked）**，因为某些原因放弃CPU使用权
  - 同步阻塞：线程获取synchronized同步锁失败时进入
  - 等待阻塞：通过调用线程的wait方法进入
  - 其他阻塞：调用sleep()或join()或发出了I/O请求时进入
- **死亡状态（Dead）**，通过下面的三种方式进入死亡状态：
  - 正常结束
  - 异常结束
  - 调用stop，不推荐使用，同时释放对象持有的所有锁，容易造成状态不稳定，以及死锁

#### 1.3.1 终止线程的4种方式

```java
// 1. 正常运行结束

// 2. 使用退出标志退出线程

// 3. Interrupt 方法结束线程(需要考虑阻塞（会有异常） + 非阻塞（能够查看到当前线程的状态）两种情况)
while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出
	 try{
	 	Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出
 	}catch(InterruptedException e){
 		e.printStackTrace();
		break;//捕获到异常之后，执行 break 跳出循环
 	}
}

// 4. thread.stop()进行关闭，不推荐使用，同时释放对象获取的所有锁，容易导致状态不可知
```

#### 1.4 sleep、wait、yeild、join之间的联系与区别，run和start之间的关系

> - sleep：保持锁，让出一段执行时间，没有优先级概念
>
> - wait：等待获取当前对象的同步锁（当前已经获得锁，是需要让别人通知自己是否获得锁）
>
> - yeild：交出CPU权限，重新回到就绪状态进行竞争，只给具有更高优先级的线程让步
>
> - join：等待该线程执行完

#### 1.4.1 sleep与wait

1. 所属类不同
2. 是否依然是监控状态保持者？
3. 锁是否释放？
4. 阻塞类型不同，wait需要notify进行通知

#### 1.4.2 start与run的区别

> 1. start方法用来启动线程，启动子线程后当前线程就可以**继续往下执行**
> 2. 调用start方法子线程进入**就绪状态**，等待获取cpu权限
> 3. run是一个方法体，线程**进入运行状态，开始运行run函数当前的代码**

#### 1.4.3 yield 的问题

> - Yield是一个静态的原生(native)方法
> - Yield告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。
> - Yield不能保证使得当前正在运行的线程迅速转换到可运行的状态**可能有延迟**
> - 它仅能使一个线程**从运行状态转到可运行状态，而不是等待或阻塞状态**

### 1.5 Java 后台线程

#### 1.5.1 基本概念

**定义：**守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供公共服务，在没有用户线程可服务时会自动离开。

**在调用start方法之前通过setDaemon(true)来设置，优先级较低，并且在守护线程中产生的线程也是守护线程，线程时JVM级别，只要jvm没有停止且还有其他的服务对象，线程依旧是活跃的。即说明其生命周期和系统相同**

#### 1.5.2 Daemon线程会导致finally不能执行？

>  当不存在非Daemon线程时，Daemon线程会退出，**在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或者清理资源的逻辑。**

#### 1.5.3 一个简单的java程序中包含多个线程

```java
/**
 * Created by Genge on 2016-06-07.
 */
public class MultiThread {
    public static void main(String[] args) {
        ThreadInfo[] threadInfos = ManagementFactory.getThreadMXBean().dumpAllThreads(false, false);
        for (ThreadInfo threadInfo : threadInfos){
            System.out.println("[" + threadInfo.getThreadId() + "]" + threadInfo.getThreadName());
        }

    }
}

// 运行结果如下：
[10]Monitor Ctrl-Break
[5]Attach Listener       //添加事件
[4]Signal Dispatcher    // 分发处理给JVM信号的线程
[3]Finalizer           //调用对象finalize方法的线程
[2]Reference Handler   //清楚reference线程
[1]main   //main线程,程序入口
```

#### 1.5.4 线程优先级Priority参数靠谱吗？

> 不靠谱，**线程优先级不能作为程序正确性的依赖！**





## 2. 集合工具类（Collections）
### 2.1 CopyOnWriteArrayList
和ReetrantReadWriteLock读写锁的思想非常类似，也是存在写则互斥，或者否则共享。读取完全不用加锁，写入也不会阻塞读取操作。

**原理：**类中所有的可变操作都是通过创建底层数组的新副本来实现。写入操作在添加集合的时候加了锁，保证了同步，避免了多线程写的时候回copy出多个副本来

四、java之同步集合和并发集合

### 2.2 **同步集合类**

- HashTable
- Vector
- 同步集合包装类，Collections.synchronizedMap()和Colletions.synchronizedList()

#### 2.2.1 实现原理

就是最简单的每次操作之前锁住整个表。

### 2.3 **并发集合类**

- ConcurrentHashmap
- CopyOnWriteArrayList，存在问题，数据一致性以及内存占用问题
- CopyOnWriteHashSet

#### 2.3.1 实现原理

- ConcurrentHashMap：把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。**之前是分段上锁，后面变成了针对里面的节点进行，大大地加快了并发的程度**
- CopyOnWriteArrayList：允许多个线程以**非同步的方式读**，当有线程写的时候它会将整个List复制一个副本给它。如果在**读多写少（适用场景）**这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。**原理特别简单就是在存在写时就往副本里写，写完以后更新引用**

#### 2.3.2 使用建议

一般在不需要使用多线程的情况下，只用到HashMap、ArrayList，只要真正用到多线程的时候就一定要考虑使用同步，使用同步集合或者并发集合。

### 2.4 同步集合和并发集合的性能对比

同步集合比并发集合会慢得多，主要原因是锁，同步集合会对整个May或List加锁

## 3. 原子类（Atomic）

![img](https://camo.githubusercontent.com/8d43784c43dcc9f46d3cc917066fb945fa877857/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f33302f313636633538623738353336383233343f773d3132303026683d36353726663d706e6726733d3439363135)

### 3.1 基本原子类
基本原子类主要有：

- AtomicInteger：整形原子类
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

每个类中的方法基本都是相同，类似于下面的样子：

```java
public final int get() //获取当前的值
public final int getAndSet(int newValue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement() //获取当前的值，并自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

**优点**是能够在多环境使用原子类保证线程安全

**基本原子类实现原理：**主要利用CAS（compare and swap） + volatile 和 native方法来保证原子操作，从而避免synchronized的高开销，提高执行效率。

### 3.2 数组类型原子类

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整形数组原子类
- AtomicLongArray：长整形数组原子类
- AtomicReferenceArray ：引用类型数组原子类

其中基本的方法基本相同，类似于如下所示：

```java
public final int get(int i) //获取 index=i 位置元素的值
public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue
public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndAdd(int delta) //获取 index=i 位置元素的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

### 3.3 引用类型原子类

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。

- AtomicReference：引用类型原子类
- AtomicStampedRerence：原子更新引用类型里的字段原子类
- AtomicMarkableReference ：原子更新带有标记位的引用类型

上面三个类提供的方法几乎相同，主要的功能是**为引用类型提供原子操作管理**。

```java
AtomicReference<Person> ar = new AtomicReference<Person>(); //是一个引用管理，保证引用类型处理时的原子性
```

### 3.4 对象属性修改类型原子类

如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。

- AtomicIntegerFieldUpdater:原子更新整形字段的更新器
- AtomicLongFieldUpdater：原子更新长整形字段的更新器
- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。

```java
AtomicIntegerFieldUpdater<User> a = AtomicIntegerFieldUpdater.newUpdater(User.class, "age"); //直接对象的中的作用域进行原子操作
a.getAndIncrement(user)；
```

## 4. executor

## 5. tools

##  6. AQS(AbstractQueuedSynchronizer)

![AQS](https://camo.githubusercontent.com/75950bb0b6b7ba5672236abf0c7c096a822b1d39/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d33312f36313131353836352e6a7067)

### 6.1 简单介绍

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。

###  6.2 AQS原理

**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

CLH队列是一个虚拟的双向队列。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个节点（Node）来实现锁的分配。

AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。

AQS定义两种资源共享方式：Exclusive(独占，如ReentrantLock)和Share(共享，如Semaphore、CountDownLatch、CyclicBarrier、ReadWriteLock)

使用了模板方法模式，自定义同步器需要重写下面几个AQS提供的模板方法

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

1. **Se**maphore经常用于限制获取某种资源线程数量。**

   支持公平模式和非公平模式，通过调用acquire方法得到申请许可，通过调用release释放许可。

2. **CountDownLatch（倒计时器）**

   它允许一个或多个线程等待，直到其他的线程执行完后再执行。

   三种典型用法：某一个线程开始运行前等待n个线程执行完毕；实现多个线程开始执行任务的最大并行性；死锁检测。

3. **CyclicBarrier(循环栅栏)**

   和CountDownLatch非常相似，它可以实现线程间的计数等待，但是功能比CountDownLatch更加复杂和强大。适用于多线程计算数据，最后合并计算结果的应用场景。使用实例如下所示

   ```java
   private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5); //其中5代表需要达到的等待线程条件，支持两个参数，后面可以添加一个方法优先于子线程子线程执行
   
   //子线程中操作
   cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);
   //当有五个线程调用await后才继续执行await后面的方法
   ```

   **CyclicBarrier和CountDownLatch的区别**

   1. CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。
   2. 对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
   3. CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

![CyclicBarrieråCountDownLatchçåºå"](https://camo.githubusercontent.com/5c19d9e66ffaf3d7193b01948279db9b9b3b98d3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545352539312539382545352542462538352545352541342538372545462542432539412545352542392542362545352538462539312545372539462541352545382541462538362545372542332542422545372542422539462545362538302542422545372542422539332f4151533333332e706e67)

##  7. 锁

### 7.0 锁类型

> - **乐观锁：**适用于读多写少的情况，在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作。通过CAS实现，CAS是一种原子操作吗，比较当前值跟传入值是否一样，一样则更新，否则失败。AQS框架下是乐观锁
>
> - **悲观锁：**适合频繁写的情况，悲观锁就是Synchronized

###  7.1锁优化

这里的锁优化主要是指 JVM 对 synchronized 的优化。

#### 7.1.1 自旋锁

互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

##### 7.1.1.1 适应性自旋锁

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由**前一次在同一个锁上的自旋次数及锁的拥有者的状态**来决定。（**能够动态地不断优化自旋时间**）

##### 7.1.1.2 优缺点

> **是优点也是缺点，主要看场合**
>
> **优点：**锁竞争不是特别激烈的时候，性能提升明显
>
> **缺点：**锁竞争特别激烈的时候，性能明显下降

##### 7.1.1.3 自旋锁的开启

JDK1.6 中-XX:+UseSpinning 开启；
-XX:PreBlockSpin=10 为自旋次数；
JDK1.7 后，去掉此参数，由 jvm 控制；

#### 7.1.2 锁消除

锁消除是指对于**被检测出不可能存在竞争的共享数据的锁进行消除**。

锁消除主要是通过**逃逸分**来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。
对于一些看起来没有加锁的代码，其实隐式的加了很多锁，例如每个 StringBuilder.append() 方法中都有一个同步块。

##### 7.1.2.1 逃逸分析
逃逸分析的基本行为就是分析对象动态作用域,即对象可以在作用域外访问则说明发生了逃逸。
**方法逃逸:**：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。
**线程逃逸:** 甚至可以被外部线程访问，则称为线程逃逸。

####### 7.1.2.1.1 基于逃逸分析可以实现：
一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

#### 7.1.3 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。
如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部

#### 7.1.4 轻量级锁

JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。

![img](https://cyc2018.github.io/CS-Notes/pics/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png)

下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。

![img](https://cyc2018.github.io/CS-Notes/pics/051e436c-0e46-4c59-8f67-52d89d656182.png)

轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

![img](https://cyc2018.github.io/CS-Notes/pics/baaa681f-7c52-4198-a5ae-303b9386cf47.png)

如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

#### 7.1.5 偏向锁

偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。**让第一个获取锁对象的线程之后不用再次获取锁**

当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

![img](https://cyc2018.github.io/CS-Notes/pics/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg)

### 7.2 Synchronized同步锁

#### 7.2.1 Synchronized作用范围

**Synchronized同步锁是作用在对象上，基于此判断能否锁住以及是否是在请求同一把锁**

> this：非静态方法
>
> .class：静态方法
>
> 对象实例：同步代码块

#### 7.2.2 Synchronized核心组件

> 1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；
> 2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；
> 3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；
> 4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；
> 5) Owner：当前已经获取到所资源的线程被称为 Owner；
> 6) !Owner：当前释放锁的线程。

#### 7.2.3 Synchronized实现

![Synchronized实现](https://s2.ax1x.com/2019/03/23/AJBoBq.png)

> 1. JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。
> 2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。
> 3. Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。
> 4. OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。
> 5. 处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。
> 6. Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。参考：https://blog.csdn.net/zqz_zqz/article/details/70233767
> 7. 每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的
> 8. synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。
> 9. Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。
> 10. 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；
> 11. JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。

## 8. 关于多线线程的一些理解

### 8.1 各个Thread之间的关系（独立，各自的异常不会影响对方）

![img](https://cyc2018.github.io/CS-Notes/pics/96706658-b3f8-4f32-8eb3-dcb7fc8d5381.jpg)

各个线程在创建完成之后就分道扬镳了，一个线程的死亡不会影响到其他线程（Deamon线程会随着被守护线程而消亡）。所以一个线程死亡之前把屁股擦干净。

### 8.2 Interrupt总结

调用线程的**interrupt方法仅能立即打断那些在阻塞状态或者挂起的线程对象（通过抛出异常方式立即处理）**，但是对于正在正常运行的代码块，仅能接受到通知，如果不显示地查看自己的状态（调用线程对象的isInterrupted方法查看是否已经被打断）根本不知道自己已经被打断。这也从另外一个侧面说明一个问题，最好不要使用从外部打断的方式来结束一个正在运行的线程，最好在线程内部自己主动查看标志判断自己是否需要退出。

- 当一个线程被打断之后就不能再次进行线程的调度，即调用sleep、wait、yield等代码块会抛出异常



## 参考资料

- [JAVA 线程状态及转化](https://www.cnblogs.com/happy-coder/p/6587092.html)
- [Java多线程基础知识疑难点](<https://blog.csdn.net/huzhigenlaohu/article/details/51627201#%E6%9C%80%E7%AE%80%E5%8D%95java%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%90%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B>)