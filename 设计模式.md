# 设计模式

## 原则

### 1. 基本原则：

- 单一职责
- 开放封闭原则
- 里式替换原则
- 接口分离原则
- 依赖倒置原则：意味着，任何变量不应该持有一个指向具体类的指针或者引用，任何类都不应该从具体类派生、任何方法都不应该覆写基类中已经实现的方法

### 2. 其他常见原则

- 迪米特法则，不要和陌生人说话
- 合成复用，尽量使用对象组合，而不是通过继承来达到复用的目的
- 共同封闭原则，一起修改的类应该组合在一起。
- 稳定抽象原则，最稳定的包应该是最抽象的包，不稳定的包应该是具体包。
- 稳定依赖原则，包之间的依赖关系应该是稳定方向依赖的，包依赖的包应该比自己更加稳定

## 1. 分类

### 1.1 创建型模式

对实例化过程进行了抽象，能够将软件模块中的对象的创建和对象的使用分离。同时为了结构更加清晰以及使整个符合单一职责原则，对外界仅提供共同的接口，而不清楚其具体的实现细节。

创建模式对创建什么（What）、谁创建（Who）、何时创建（When）等方面为软件设计者提供了尽可能大的灵活性。

![åå"ºåæ¨¡å¼](https://camo.githubusercontent.com/7ce3bf527e7e5ee1e41c0a62536d8e4ea15412eb/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f362f31362f313634303634316166636237353539623f773d34393126683d32343126663d706e6726733d3531343433)

### 1.2 结构模式

如何将类或者对象结合在一起形成更大的结构。

又可以分为：

- **类结构型模式**：关心类的组合，由多个类可以组合成为一个更大的系统，在系统结构模式中一般只存在**继承关系和实现。**
- **对象结构模式**：关系类和对象的组合，通过关联关系在一个类中定义另一个类的实例对象（**关联实例对象**），然后通过**对象调用方法**。**根据合成复用原则，尽可能使用合成关系来替代继承关系，因此对象结构型模式居多**

![ç"æåæ¨¡å¼](https://camo.githubusercontent.com/82aa35f2cea3018d430d1ab4d8aedfa23cbdb9ee/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f362f31362f313634303635353435396437363664323f773d33373826683d32363626663d706e6726733d3539363532)

### 1.3 行为模式

概述：

- 是对不同对象之间**划分责任和算法的抽象**
- 不仅关注类和对象的结构，还关注他们之间的**相互作用**
- 更加清晰划分类和对象的职责，并研究系统在运行时**实例对象之间的交互。**

又可以分为：

- **类行为模式：** 类的行为模式中主要通过继承在几个类中分配行为，通过多态等方式来分配父类和子类的职责。
- **对象行为模式：**对象的行为模式使用对象的**聚合、关联**关系来分配行为，**根据合成复用原则**尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

![è¡ä¸ºåæ¨¡å¼](https://camo.githubusercontent.com/95e804c7b24a9e61d360d1b868b32afea657d72a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f362f32382f313634343637646439326336313732633f773d34353326683d32363926663d706e6726733d3633323730)

## 2. 创建型模式

### 2.1 抽象型工厂模式

从具体的产品中解耦，定义接口和产品超类，子类中仅依附于接口和超类，不同的工厂实现不同的接口方法，客户端从产品超类中对象转为期望的子类产品。并且工厂中能够生产的是一组相互之间具有关系或者依赖的产品。但是修改时造成需要级联修改，不是特别方便。

![抽象工厂模式](http://cmsblogs.com/wp-content/uploads/2014/02/jpeg_thumb.png)

### 2.2 简单工厂模式

严格来说不是23种设计模式中的一种，

定义一个抽象的机器接口，每个产品需要创建一个类实现对应的机器接口，在外层再定义一个类根据传入的参数选择机器生产合适的产品。

### 2.3 工厂方法模式

定义一个创建对象的接口，由子类决定要实例化的类是哪一个。也就是说每个产品配套一个工厂。

![å·¥åŽ'æ–¹æ³•æ¨¡å¼](http://cmsblogs.com/wp-content/uploads/2014/02/thumb.png)

### 2.4 建造者模式

建造者模式中将产品的构建和表示分离，定义接口将构建过程划分为多个步骤，定义一个额外的类将创建过程封装（即将接口作为一个对象，定义产品的构建方法，在方法内部调用接口中方法完成构建任务），适用于产品的创建比较复杂的情况。

![建造者UML结构图](http://cmsblogs.com/wp-content/uploads/2014/02/thumb1.jpg)

### 2.5 原型模式

对于频繁使用的对象通过克隆的方式进行生成，加快对象创建的速度，主要应用于创建对象成本过大的情况。

![åŽŸåž'æ¨¡å¼](http://cmsblogs.com/wp-content/uploads/2014/02/thumb1.png)

### 2.6 单例模式

确保类只有一个实例，并且提供全局的访问点。

具有的特点：

- 只有一个实例
- 能够自我实例化
- 提供全局的访问点

![单例模式UML图](http://cmsblogs.com/wp-content/uploads/2014/02/thumb2.png)

##  3. 结构型模式

### 3.1 适配器模式

将不同的接口组合成为一个符合客户期望的另外一个接口（对接口进行个性化封装）。将目标与类和适配器解耦，增加类的透明性和可复用性。
![适配器模式UML图](http://cmsblogs.com/wp-content/uploads/2014/02/thumb3.png)

***

后面的不写了，具体看StackEdit里面的文章...